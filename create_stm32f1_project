#!/bin/sh

if [ "$1" = "--help" ]
  then 
      echo ""
      echo "    STM32F1 Project Creator v0.01 ALPHA";
      echo "wget, st-utility and GNU Arm Embedded Toolchain are required"
      echo
      echo "Usage:"
      echo "        $0 [command] [options]"
      echo 
      echo "Commands:"
      echo "        mdk  generate simple Keil MDK-ARM config" 
      exit
fi


wg="wget -c"
raw=https://raw.githubusercontent.com
st=$raw/STMicroelectronics/
cmsis=$st/STM32CubeF1/master/Drivers/CMSIS/Include
f1=$st/cmsis_device_f1/master
# https://raw.githubusercontent.com/STMicroelectronics/cmsis_device_f1/master
# /Source/Templates/arm/startup_stm32f103xb.s
svd="https://raw.githubusercontent.com/posborne/cmsis-svd/master/data/STMicro/STM32F103xx.svd"

$wg $cmsis/cmsis_compiler.h $cmsis/cmsis_gcc.h $cmsis/cmsis_version.h $cmsis/core_cm3.h \
    $f1/Include/stm32f1xx.h $f1/Include/stm32f103xb.h $f1/Include/system_stm32f1xx.h $f1/Source/Templates/system_stm32f1xx.c \
    $f1/Source/Templates/gcc/startup_stm32f103xb.s $f1/Source/Templates/gcc/linker/STM32F103XB_FLASH.ld $svd


if [ "$1" = "mdk" ]
  then 
  $wg $cmsis/cmsis_armclang.h 
  mkdir MDK-ARM
  cd MDK-ARM
  $wg $f1/Source/Templates/arm/startup_stm32f103xb.s
  cat << MDK_CONFIG > project.uvprojx
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<Project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="project_projx.xsd">

  <SchemaVersion>2.1</SchemaVersion>

  <Header>### uVision Project, (C) Keil Software</Header>

  <Targets>
    <Target>
      <TargetName>project</TargetName>
      <ToolsetNumber>0x4</ToolsetNumber>
      <ToolsetName>ARM-ADS</ToolsetName>
      <pCCUsed>6160000::V6.16::ARMCLANG</pCCUsed>
      <uAC6>1</uAC6>
      <TargetOption>
        <TargetCommonOption>
          <Device>STM32F103CB</Device>
          <Vendor>STMicroelectronics</Vendor>
          <PackID>Keil.STM32F1xx_DFP.2.3.0</PackID>
          <PackURL>http://www.keil.com/pack/</PackURL>
          <Cpu>IRAM(0x20000000,0x00005000) IROM(0x08000000,0x00020000) CPUTYPE("Cortex-M3") CLOCK(8000000) ELITTLE</Cpu>
          <FlashUtilSpec></FlashUtilSpec>
          <StartupFile></StartupFile>
          <FlashDriverDll>UL2CM3(-S0 -C0 -P0 -FD20000000 -FC1000 -FN1 -FF0STM32F10x_128 -FS08000000 -FL020000 -FP0($$Device:STM32F103CB$Flash\STM32F10x_128.FLM))</FlashDriverDll>
          <DeviceId>0</DeviceId>
          <RegisterFile>$$Device:STM32F103CB$Device\Include\stm32f10x.h</RegisterFile>
          <MemoryEnv></MemoryEnv>
          <Cmp></Cmp>
          <Asm></Asm>
          <Linker></Linker>
          <OHString></OHString>
          <InfinionOptionDll></InfinionOptionDll>
          <SLE66CMisc></SLE66CMisc>
          <SLE66AMisc></SLE66AMisc>
          <SLE66LinkerMisc></SLE66LinkerMisc>
          <SFDFile>$$Device:STM32F103CB$SVD\STM32F103xx.svd</SFDFile>
          <bCustSvd>0</bCustSvd>
          <UseEnv>0</UseEnv>
          <BinPath></BinPath>
          <IncludePath></IncludePath>
          <LibPath></LibPath>
          <RegisterFilePath></RegisterFilePath>
          <DBRegisterFilePath></DBRegisterFilePath>
          <TargetStatus>
            <Error>0</Error>
            <ExitCodeStop>0</ExitCodeStop>
            <ButtonStop>0</ButtonStop>
            <NotGenerated>0</NotGenerated>
            <InvalidFlash>1</InvalidFlash>
          </TargetStatus>
          <OutputDirectory>.\OUTPUT\</OutputDirectory>
          <OutputName>project</OutputName>
          <CreateExecutable>1</CreateExecutable>
          <CreateLib>0</CreateLib>
          <CreateHexFile>1</CreateHexFile>
          <DebugInformation>1</DebugInformation>
          <BrowseInformation>1</BrowseInformation>
          <ListingPath></ListingPath>
          <HexFormatSelection>1</HexFormatSelection>
          <Merge32K>0</Merge32K>
          <CreateBatchFile>0</CreateBatchFile>
          <BeforeCompile>
            <RunUserProg1>0</RunUserProg1>
            <RunUserProg2>0</RunUserProg2>
            <UserProg1Name></UserProg1Name>
            <UserProg2Name></UserProg2Name>
            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
            <nStopU1X>0</nStopU1X>
            <nStopU2X>0</nStopU2X>
          </BeforeCompile>
          <BeforeMake>
            <RunUserProg1>0</RunUserProg1>
            <RunUserProg2>0</RunUserProg2>
            <UserProg1Name></UserProg1Name>
            <UserProg2Name></UserProg2Name>
            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
            <nStopB1X>0</nStopB1X>
            <nStopB2X>0</nStopB2X>
          </BeforeMake>
          <AfterMake>
            <RunUserProg1>0</RunUserProg1>
            <RunUserProg2>0</RunUserProg2>
            <UserProg1Name></UserProg1Name>
            <UserProg2Name></UserProg2Name>
            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
            <nStopA1X>0</nStopA1X>
            <nStopA2X>0</nStopA2X>
          </AfterMake>
          <SelectedForBatchBuild>1</SelectedForBatchBuild>
          <SVCSIdString></SVCSIdString>
        </TargetCommonOption>
        <CommonProperty>
          <UseCPPCompiler>0</UseCPPCompiler>
          <RVCTCodeConst>0</RVCTCodeConst>
          <RVCTZI>0</RVCTZI>
          <RVCTOtherData>0</RVCTOtherData>
          <ModuleSelection>0</ModuleSelection>
          <IncludeInBuild>1</IncludeInBuild>
          <AlwaysBuild>0</AlwaysBuild>
          <GenerateAssemblyFile>0</GenerateAssemblyFile>
          <AssembleAssemblyFile>0</AssembleAssemblyFile>
          <PublicsOnly>0</PublicsOnly>
          <StopOnExitCode>3</StopOnExitCode>
          <CustomArgument></CustomArgument>
          <IncludeLibraryModules></IncludeLibraryModules>
          <ComprImg>0</ComprImg>
        </CommonProperty>
        <DllOption>
          <SimDllName>SARMCM3.DLL</SimDllName>
          <SimDllArguments> -REMAP</SimDllArguments>
          <SimDlgDll>DCM.DLL</SimDlgDll>
          <SimDlgDllArguments>-pCM3</SimDlgDllArguments>
          <TargetDllName>SARMCM3.DLL</TargetDllName>
          <TargetDllArguments></TargetDllArguments>
          <TargetDlgDll>TCM.DLL</TargetDlgDll>
          <TargetDlgDllArguments>-pCM3</TargetDlgDllArguments>
        </DllOption>
        <DebugOption>
          <OPTHX>
            <HexSelection>1</HexSelection>
            <HexRangeLowAddress>0</HexRangeLowAddress>
            <HexRangeHighAddress>0</HexRangeHighAddress>
            <HexOffset>0</HexOffset>
            <Oh166RecLen>16</Oh166RecLen>
          </OPTHX>
        </DebugOption>
        <Utilities>
          <Flash1>
            <UseTargetDll>1</UseTargetDll>
            <UseExternalTool>0</UseExternalTool>
            <RunIndependent>0</RunIndependent>
            <UpdateFlashBeforeDebugging>1</UpdateFlashBeforeDebugging>
            <Capability>1</Capability>
            <DriverSelection>4101</DriverSelection>
          </Flash1>
          <bUseTDR>1</bUseTDR>
          <Flash2>BIN\UL2CM3.DLL</Flash2>
          <Flash3></Flash3>
          <Flash4></Flash4>
          <pFcarmOut></pFcarmOut>
          <pFcarmGrp></pFcarmGrp>
          <pFcArmRoot></pFcArmRoot>
          <FcArmLst>0</FcArmLst>
        </Utilities>
        <TargetArmAds>
          <ArmAdsMisc>
            <GenerateListings>0</GenerateListings>
            <asHll>1</asHll>
            <asAsm>1</asAsm>
            <asMacX>1</asMacX>
            <asSyms>1</asSyms>
            <asFals>1</asFals>
            <asDbgD>1</asDbgD>
            <asForm>1</asForm>
            <ldLst>0</ldLst>
            <ldmm>1</ldmm>
            <ldXref>1</ldXref>
            <BigEnd>0</BigEnd>
            <AdsALst>1</AdsALst>
            <AdsACrf>1</AdsACrf>
            <AdsANop>0</AdsANop>
            <AdsANot>0</AdsANot>
            <AdsLLst>1</AdsLLst>
            <AdsLmap>1</AdsLmap>
            <AdsLcgr>1</AdsLcgr>
            <AdsLsym>1</AdsLsym>
            <AdsLszi>1</AdsLszi>
            <AdsLtoi>1</AdsLtoi>
            <AdsLsun>1</AdsLsun>
            <AdsLven>1</AdsLven>
            <AdsLsxf>1</AdsLsxf>
            <RvctClst>0</RvctClst>
            <GenPPlst>0</GenPPlst>
            <AdsCpuType>"Cortex-M3"</AdsCpuType>
            <RvctDeviceName></RvctDeviceName>
            <mOS>0</mOS>
            <uocRom>0</uocRom>
            <uocRam>0</uocRam>
            <hadIROM>1</hadIROM>
            <hadIRAM>1</hadIRAM>
            <hadXRAM>0</hadXRAM>
            <uocXRam>0</uocXRam>
            <RvdsVP>0</RvdsVP>
            <RvdsMve>0</RvdsMve>
            <RvdsCdeCp>0</RvdsCdeCp>
            <hadIRAM2>0</hadIRAM2>
            <hadIROM2>0</hadIROM2>
            <StupSel>8</StupSel>
            <useUlib>1</useUlib>
            <EndSel>0</EndSel>
            <uLtcg>0</uLtcg>
            <nSecure>0</nSecure>
            <RoSelD>3</RoSelD>
            <RwSelD>3</RwSelD>
            <CodeSel>0</CodeSel>
            <OptFeed>0</OptFeed>
            <NoZi1>0</NoZi1>
            <NoZi2>0</NoZi2>
            <NoZi3>0</NoZi3>
            <NoZi4>0</NoZi4>
            <NoZi5>0</NoZi5>
            <Ro1Chk>0</Ro1Chk>
            <Ro2Chk>0</Ro2Chk>
            <Ro3Chk>0</Ro3Chk>
            <Ir1Chk>1</Ir1Chk>
            <Ir2Chk>0</Ir2Chk>
            <Ra1Chk>0</Ra1Chk>
            <Ra2Chk>0</Ra2Chk>
            <Ra3Chk>0</Ra3Chk>
            <Im1Chk>1</Im1Chk>
            <Im2Chk>0</Im2Chk>
            <OnChipMemories>
              <Ocm1>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm1>
              <Ocm2>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm2>
              <Ocm3>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm3>
              <Ocm4>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm4>
              <Ocm5>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm5>
              <Ocm6>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm6>
              <IRAM>
                <Type>0</Type>
                <StartAddress>0x20000000</StartAddress>
                <Size>0x5000</Size>
              </IRAM>
              <IROM>
                <Type>1</Type>
                <StartAddress>0x8000000</StartAddress>
                <Size>0x20000</Size>
              </IROM>
              <XRAM>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </XRAM>
              <OCR_RVCT1>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT1>
              <OCR_RVCT2>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT2>
              <OCR_RVCT3>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT3>
              <OCR_RVCT4>
                <Type>1</Type>
                <StartAddress>0x8000000</StartAddress>
                <Size>0x20000</Size>
              </OCR_RVCT4>
              <OCR_RVCT5>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT5>
              <OCR_RVCT6>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT6>
              <OCR_RVCT7>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT7>
              <OCR_RVCT8>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT8>
              <OCR_RVCT9>
                <Type>0</Type>
                <StartAddress>0x20000000</StartAddress>
                <Size>0x5000</Size>
              </OCR_RVCT9>
              <OCR_RVCT10>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT10>
            </OnChipMemories>
            <RvctStartVector></RvctStartVector>
          </ArmAdsMisc>
          <Cads>
            <interw>1</interw>
            <Optim>3</Optim>
            <oTime>0</oTime>
            <SplitLS>0</SplitLS>
            <OneElfS>1</OneElfS>
            <Strict>0</Strict>
            <EnumInt>0</EnumInt>
            <PlainCh>0</PlainCh>
            <Ropi>0</Ropi>
            <Rwpi>0</Rwpi>
            <wLevel>2</wLevel>
            <uThumb>0</uThumb>
            <uSurpInc>0</uSurpInc>
            <uC99>1</uC99>
            <uGnu>0</uGnu>
            <useXO>0</useXO>
            <v6Lang>6</v6Lang>
            <v6LangP>9</v6LangP>
            <vShortEn>1</vShortEn>
            <vShortWch>1</vShortWch>
            <v6Lto>0</v6Lto>
            <v6WtE>1</v6WtE>
            <v6Rtti>0</v6Rtti>
            <VariousControls>
              <MiscControls>-Wno-missing-prototypes -Wno-unreachable-code-return</MiscControls>
              <Define>STM32F103xB,USE_SWD=1</Define>
              <Undefine></Undefine>
              <IncludePath>..</IncludePath>
            </VariousControls>
          </Cads>
          <Aads>
            <interw>1</interw>
            <Ropi>0</Ropi>
            <Rwpi>0</Rwpi>
            <thumb>0</thumb>
            <SplitLS>0</SplitLS>
            <SwStkChk>0</SwStkChk>
            <NoWarn>0</NoWarn>
            <uSurpInc>0</uSurpInc>
            <useXO>0</useXO>
            <ClangAsOpt>4</ClangAsOpt>
            <VariousControls>
              <MiscControls></MiscControls>
              <Define></Define>
              <Undefine></Undefine>
              <IncludePath></IncludePath>
            </VariousControls>
          </Aads>
          <LDads>
            <umfTarg>1</umfTarg>
            <Ropi>0</Ropi>
            <Rwpi>0</Rwpi>
            <noStLib>0</noStLib>
            <RepFail>1</RepFail>
            <useFile>0</useFile>
            <TextAddressRange></TextAddressRange>
            <DataAddressRange></DataAddressRange>
            <pXoBase></pXoBase>
            <ScatterFile></ScatterFile>
            <IncludeLibs></IncludeLibs>
            <IncludeLibsPath></IncludeLibsPath>
            <Misc></Misc>
            <LinkerInputFile></LinkerInputFile>
            <DisabledWarnings></DisabledWarnings>
          </LDads>
        </TargetArmAds>
      </TargetOption>
      <Groups>
        <Group>
          <GroupName>startup</GroupName>
          <Files>
            <File>
              <FileName>startup_stm32f103xb.s</FileName>
              <FileType>2</FileType>
              <FilePath>startup_stm32f103xb.s</FilePath>
            </File>
            <File>
              <FileName>system_stm32f1xx.c</FileName>
              <FileType>1</FileType>
              <FilePath>../system_stm32f1xx.c</FilePath>
            </File>
          </Files>
        </Group>
        <Group>
          <GroupName>app</GroupName>
          <Files>
            <File>
              <FileName>main.c</FileName>
              <FileType>1</FileType>
              <FilePath>../main.c</FilePath>
            </File>
          </Files>
        </Group>
      </Groups>
    </Target>
  </Targets>
</Project>
MDK_CONFIG
  cd ..
fi


#
# generate main.h
#

cat <<MAIN_H >main.h
#ifndef __MAIN_H
#define __MAIN_H

#include "stm32f1xx.h"

#ifdef __cplusplus
 extern C {
#endif

/* *********************************************************************************** */
/* ******** Uncomment lines below if these features are required ********************* */
/* *********************************************************************************** */
#if 0
  #define USE_HSE                       1  /* Use crystall oscillator as clock source  */
  #define USE_PLL                       1  /* Use PLL as system clock source           */
  #define USE_USART                     1  /* Configure USART1 for send and receive    */
  #define USE_I2C                       1  /* Configure I2C1 100kHz                    */
  #define USE_SPI                       1  /* Configure SPI1                           */
  #define USE_BTN                       1  /* Use buttons connected to PB1 and PB2     */
  #define USE_RTC                       1  /* Configure and run RTC                    */
  #define USE_SWD                       1  /* Use SWD pins for debugging               */
#endif
/* *********************************************************************************** */
/* ********  or force using them while running make utility  ************************* */
/* *********************************************************************************** */


#define PORT_CFG(PORT, CFG)             *(__IO uint64_t*) GPIO ## PORT ## _BASE = (CFG)
#define PIN_CFG(PIN, MODE)              ((MODE) << ((PIN) * 4))
                                                                                       /*
    In input mode (MODE[1:0] = 00):

  00: Analog mode
  01: Floating input (reset state)
  10: Input with pull-up / pull-down
  11: Reserved
                                                                                       */
#define I_ANALOG                        (0ULL << 2)
#define I_FLOAT                         (1ULL << 2)
#define I_PULL                          (2ULL << 2)
                                                                                       /*
    In output mode (MODE[1:0] > 00):

  00: General purpose output push-pull
  01: General purpose output Open-drain
  10: Alternate function output Push-pull
  11: Alternate function output Open-drain
                                                                                       */
#define O_PP                            (0ULL << 2)
#define O_OD                            (1ULL << 2)
#define O_AF                            (2ULL << 2)
                                                                                       /*
  MODEy[1:0]: Port x mode bits (y = 0 .. 7)
  These bits are written by software to configure the corresponding I/O port.
  Refer to Table 20: Port bit configuration table.

  00: Input mode (reset state)
  01: Output mode, max speed 10 MHz.
  10: Output mode, max speed 2 MHz.
  11: Output mode, max speed 50 MHz.
                                                                                       */
#define O_10MHZ                         1ULL
#define O_2MHZ                          2ULL
#define O_50MHZ                         3ULL

#define DOWN                            GPIO_BSRR_BR
#define UP                              GPIO_BSRR_BS

#define CAT(A, B)                       A ## B
#define SW_PIN(PORT, PIN, STATE)        GPIO ## PORT->BSRR = CAT(STATE, PIN)
#define PULL(PIN, STATE)                CAT(STATE, PIN)
#define HIGH(PIN)                       GPIO_BSRR_BS ## PIN
#define LOW(PIN)                        GPIO_BSRR_BR ## PIN

#define ATOMIC_OUT(PORT, DATA)          PORT->BSRR = 0x00FF0000 | (DATA)
#define READ_PIN(PORT, PIN)             (GPIO ## PORT->IDR & GPIO_IDR_IDR ## PIN)

#define GET_TICK()                      (SysTick->CTRL >> SysTick_CTRL_COUNTFLAG_Pos)
#define DELAY_MS(MS)                    do {(void)SysTick->CTRL; for(unsigned _ = MS; _; _ -= GET_TICK()) {}}while(0)

#define WAIT_FOR_FLAG(REG, FLAG, TIMEOUT) do {                                  \\
          unsigned timeout = SysTick->CTRL >> (SysTick_CTRL_COUNTFLAG_Pos + 1); \\
          while(((REG) & (FLAG)) != (FLAG)) {                                   \\
            timeout += GET_TICK();                                              \\
            if (timeout > (TIMEOUT)) {                                          \\
              return ERROR;                                                     \\
            }                                                                   \\
          }                                                                     \\
        } while(0)

#if defined(USE_SWD) && (USE_SWD != 0)
  #define SWD_EN                        1
#else
  #define SWD_EN                        0
#endif

#if defined(USE_USART) && (USE_USART != 0)
  #define USART_EN                      1
#else
  #define USART_EN                      0
#endif

#if defined(USE_BTN) && (USE_BTN != 0)
  #define BTN_EN                        1
#else
  #define BTN_EN                        0
#endif

#if defined(USE_I2C) && (USE_I2C != 0)
  #define I2C_EN                        1
  #define I2C_SPEED_STANDARD            100000
  #define I2C_SPEED_FAST                400000

  #if 0
    #define I2C_SPEED_MODE              I2C_SPEED_STANDARD
  #else
    #define I2C_SPEED_MODE              I2C_SPEED_FAST
  #endif

  #define I2C_DUTY_CYCLE_2              0x00000000U                      /* I2C fast mode Tlow/Thigh = 2        */
  #define I2C_DUTY_CYCLE_16_9           I2C_CCR_DUTY                     /* I2C fast mode Tlow/Thigh = 16/9     */

  #define I2C_CONFIGURE_CCR(APB1_CLOCK, I2C_SPEED)                       (uint32_t)(((I2C_SPEED) <= I2C_SPEED_STANDARD)? \
                                                                         (I2C_CONFIGURE_CCR_STANDARD((APB1_CLOCK), (I2C_SPEED))) : \
                                                                         (I2C_CONFIGURE_CCR_FAST((APB1_CLOCK), (I2C_SPEED), (I2C_DUTY_CYCLE_2))))

  #define I2C_CONFIGURE_CCR_STANDARD(APB1_CLOCK, I2C_SPEED)              (uint32_t)(((((APB1_CLOCK)/((I2C_SPEED) << 1U)) & I2C_CCR_CCR) < 4U) ? 4U:((APB1_CLOCK) / ((I2C_SPEED) << 1U)))

  #define I2C_CONFIGURE_CCR_FAST(APB1_CLOCK, I2C_SPEED, I2C_DUTY_CYCLE)  (uint32_t)(((I2C_DUTY_CYCLE) == I2C_DUTY_CYCLE_2) ? \
                                                                         (((((APB1_CLOCK) / ((I2C_SPEED) * 3U)) & I2C_CCR_CCR) == 0U) ? 1U:((APB1_CLOCK) / ((I2C_SPEED) * 3U))) : \
                                                                         (((((APB1_CLOCK) / ((I2C_SPEED) * 25U)) & I2C_CCR_CCR) == 0U) ? 1U:((APB1_CLOCK) / ((I2C_SPEED) * 25U))))

  #define I2C_RISE_TIME(APB1_CLOCK, I2C_SPEED)                           (uint32_t)(((I2C_SPEED) <= I2C_SPEED_STANDARD) ? ((APB1_CLOCK) / 1000000 + 1) : ((((APB1_CLOCK) / 1000000) * 300) / 1000) + 1)
#else
  #define I2C_EN                        0
#endif

#if defined(USE_SPI) && (USE_SPI != 0)

  #define SPI_EN                        1

  __STATIC_INLINE char spi_xfer(char d) {
    while((SPI1->SR & SPI_SR_TXE) != SPI_SR_TXE) {
      /* wait until spi transfer completes */
    }
    *((__IO char *)&SPI1->DR) = d;
    while((SPI1->SR & SPI_SR_RXNE) != SPI_SR_RXNE) {
      /* wait until spi transfer completes */
    }
    return *(__IO char *)&SPI1->DR;
  }

  #define CS_PORT                       GPIOA
  #define CS_PIN                        4
  #define CS(STATE)                     CS_PORT->BSRR = (1UL << ((!STATE) * 16 + CS_PIN))
  #define CS_LOW()                      CS(0)
  #define CS_HIGH()                     CS(1)

#else
  #define SPI_EN                        0
#endif


__STATIC_INLINE void init(void) {

  RCC->APB2ENR = (

    #if USART_EN
      RCC_APB2ENR_USART1EN        |                           /* Enable clock for USART1            */
      RCC_APB2ENR_IOPAEN          |                           /* Enable clock for GPIOA             */
    #endif

    #if SPI_EN
      RCC_APB2ENR_IOPAEN          |                           /* Enable clock for GPIOA             */
      RCC_APB2ENR_SPI1EN          |                           /* Enable clock for SPI1              */
    #endif

    #if I2C_EN || BTN_EN
      RCC_APB2ENR_IOPBEN          |                           /* Enable clock for GPIOB             */
    #endif

    RCC_APB2ENR_AFIOEN            |                           /* Enable clock for AFIO              */

    #if SWD_EN
      RCC_APB2ENR_IOPAEN          |                           /* Enable clock for GPIOA             */
    #endif

    RCC_APB2ENR_IOPCEN                                        /* Enable clock for GPIOC             */
  );

  #if I2C_EN

    RCC->APB1ENR = (
      I2C_EN * RCC_APB1ENR_I2C1EN                             /* Enable clock for I2C1              */
    );
  #endif

  #if I2C_EN || BTN_EN
    PORT_CFG(B, 
      BTN_EN   * PIN_CFG(0,  I_PULL)                |         /* PB0:  input, pull-up               */
      BTN_EN   * PIN_CFG(1,  I_PULL)                |         /* PB1:  input, pull-up               */
      I2C_EN   * PIN_CFG(6,  O_AF + O_OD + O_10MHZ) |         /* PB6:  I2C1 SCL, altern, open drain */
      I2C_EN   * PIN_CFG(7,  O_AF + O_OD + O_10MHZ)           /* PB7:  I2C1 SDA, altern, open drain */
    );
  #endif

  #if BTN_EN
     GPIOB->BSRR = GPIO_BSRR_BS0 | GPIO_BSRR_BS1;
  #endif

  PORT_CFG(C, PIN_CFG(13, O_2MHZ));                           /* PC13: output, push-pull, 2Mhz      */
  SW_PIN(C, 13, UP);                                          /* Set PC13 pin HIGH (LED off)        */

  #if USART_EN || SWD_EN || SPI_EN

    PORT_CFG(A, 
      SPI_EN   * PIN_CFG(4,  O_10MHZ)        |                /* PA4:  SPI1 CS, output, 10MHz       */
      SPI_EN   * PIN_CFG(5,  O_AF + O_50MHZ) |                /* PA5:  SPI1 CLK, alternate, 50MHz   */
      SPI_EN   * PIN_CFG(6,  I_PULL)         |                /* PA6:  SPI1 MISO, input, pull-down  */
      SPI_EN   * PIN_CFG(7,  O_AF + O_50MHZ) |                /* PA7:  SPI1 MOSI, alternate, 50MHz  */
      USART_EN * PIN_CFG(9,  O_AF + O_10MHZ) |                /* PA9:  USART1 TX, alternate, 10MHz  */
      USART_EN * PIN_CFG(10, I_PULL)         |                /* PA10: USART1 RX, input, pull-down  */
      SWD_EN   * PIN_CFG(13, I_PULL)         |                /* PA13: SWDIO, input, pull-up        */
      SWD_EN   * PIN_CFG(14, I_PULL)                          /* PA14: SWCLK, input, pull-down      */
    );

    GPIOA->BSRR = (
      SPI_EN   * PULL(6,  DOWN) |                             /* Pull-down SPI1 MISO pin            */
      USART_EN * PULL(10, DOWN) |                             /* Pull-down USART1 RX pin            */
      SWD_EN   * PULL(13, UP)   |                             /* Pull-up SWDIO pin                  */
      SWD_EN   * PULL(14, DOWN)                               /* Pull-down SWCLK pin                */
    );

  #endif

  #if SWD_EN
    AFIO->MAPR = AFIO_MAPR_SWJ_CFG_JTAGDISABLE;               /* Disable JTAG, enable SWD           */
  #else
    AFIO->MAPR = AFIO_MAPR_SWJ_CFG_DISABLE;                   /* Disable both JTAG and SWD          */
  #endif

  #if defined USE_HSE && USE_HSE != 0

    RCC->CR = RCC_CR_HSEON;                                   /* Switch HSE on                      */
    while((RCC->CR & RCC_CR_HSERDY) == 0) {/* NO OP */}       /* Wait until HSE becomes ready       */

    #define RCC_CFGR RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL9      /* 72 MHz: PllSrc = HSE, Mul = 9      */
    #define RCC_CR   RCC_CR_PLLON | RCC_CR_HSEON
    #define HCLK     72000000UL

  #else

    #define RCC_CFGR RCC_CFGR_PLLMULL16                       /* 64 MHz: PllSrc = HSI / 2, Mul = 16 */
    #define RCC_CR   RCC_CR_PLLON
    #define HCLK     64000000UL

  #endif

  #if defined USE_PLL && USE_PLL != 0

    RCC->CFGR = RCC_CFGR;                                     /* Configure PLL                      */
    RCC->CR = RCC_CR;                                         /* Switch PLL on                      */
    while((RCC->CR & RCC_CR_PLLRDY) == 0) { /* NO OP */}      /* Wait until PLL becomes ready       */
    FLASH->ACR = FLASH_ACR_LATENCY_1;                         /* Set flash latency to 2             */
    RCC->CFGR = (
      RCC_CFGR_SW_PLL      |                                  /* Set PLL as system clock source     */
      RCC_CFGR_PPRE1_DIV2                                     /* Set APB1 clock as HCLK / 2         */
    );

    #define APB1_CLK ((HCLK) / 2)

  #else

    #undef  HCLK
    #define HCLK     8000000UL
    #define APB1_CLK HCLK

  #endif

  SysTick->LOAD = HCLK / 8000 - 1;                            /* Set SysTick reload register        */
  SysTick->CTRL = SysTick_CTRL_ENABLE_Msk |                   /* Start SysTick timer (HCLK / 8)     */
                  SysTick_CTRL_TICKINT_Msk;

  #if USART_EN
    #define BAUDRATE 115200

    USART1->BRR = (HCLK + BAUDRATE / 2) / BAUDRATE;           /* Configure USART baud rate          */
    USART1->CR1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_UE; /* Enable USART peripheral            */
  #endif

  #if I2C_EN
    I2C1->CCR = I2C_CONFIGURE_CCR(APB1_CLK, I2C_SPEED_MODE);  /* Write CCR when I2C is disabled     */
    I2C1->TRISE = I2C_RISE_TIME(APB1_CLK, I2C_SPEED_MODE);    /* Maximum rise time in Fm/Sm mode    */
    I2C1->CR2 = APB1_CLK / 1000000;                           /* Configure Peripheral Clock Freq.   */
    I2C1->CR1 = I2C_CR1_PE;                                   /* Enable I2C1 Peripheral             */
  #endif

  #if SPI_EN
    SPI1->CR1 = (

      #if defined USE_PLL && USE_PLL != 0
        SPI_CR1_BR_0       |                                  /* Configure baudrate as HCLK / 4     */ 
      #endif

      SPI_CR1_MSTR         |                                  /* Select Master mode                 */
      SPI_CR1_SSM          |                                  /* Enable Software Slave Management   */
      SPI_CR1_SSI          |                                  /* Set Internal slave select bit      */
      SPI_CR1_SPE                                             /* Enable SPI1 Peripheral             */
    );
  #endif

}

#if USART_EN
  __STATIC_INLINE void uputc(char c) {
    while (!(USART1->SR & USART_SR_TXE)) { /* JUST WAIT */ }  /* Wait until TX reg becomes empty    */
    USART1->DR = c;
  }

  __STATIC_INLINE void uputs(char *c) {
    while(*c) {
      uputc(*c++);
    }
  }
  
  #define HEX(NIBBLE) (((NIBBLE) < 10) ? (NIBBLE) + '0' : (NIBBLE) + '7')
  
    /* Convert a nibble to HEX and send it via UART */
  __STATIC_INLINE void uput_x(const uint8_t c) {
    /* Convert a nibble to HEX char and send it via UART */
    uputc(HEX(c));
  }

    /* Convert a byte to HEX and send it via UART */
  __STATIC_INLINE void uputx(const uint8_t c) {
    uput_x(c >> 4);
    uput_x(c & 0x0F);
  }
  
  #define uprintf(...) do{char _[160]; snprintf(_, sizeof(_), __VA_ARGS__); uputs(_);}while(0)
  
#endif

#if I2C_EN

  #define I2C_TIMEOUT                   10
  #define I2C_ERR_TIMEOUT               1
  #define I2C_ERROR                     (                                                            \\
                                          I2C_SR1_BERR  |  /*  Bus Error            (0x00000100)   */\\
                                          I2C_SR1_ARLO  |  /*  Arbitration Lost     (0x00000200)   */\\
                                          I2C_SR1_AF    |  /*  Acknowledge Failure  (0x00000400)   */\\
                                          I2C_SR1_OVR      /*  Overrun/Underrun     (0x00000800)   */\\
                                        )


  extern unsigned short i2c_status;


  __STATIC_INLINE ErrorStatus i2c_check(const unsigned bitFlag) {
    unsigned t_out = I2C_TIMEOUT;
    (void) SysTick->CTRL;
  
    while((I2C1->SR1 & bitFlag) == 0) {
      t_out -= GET_TICK();
      if (t_out == 0) {
        i2c_status |= I2C_ERR_TIMEOUT;
        return ERROR;
      }
  
      unsigned e_status = I2C1->SR1 & I2C_ERROR;
      if (e_status) {
        i2c_status = (unsigned short)e_status;
        return ERROR;
      }
    }
  
    return SUCCESS;
  }
  
  
  __STATIC_INLINE ErrorStatus i2c_write(const char addr, const char *data, unsigned len) {
    I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE;
    if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;
  
    I2C1->DR = (unsigned) addr << 1;
    if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;
  
    (void) I2C1->SR2;
  
    for(unsigned i = 0; i < len; i++) {
      if (i2c_check(I2C_SR1_TXE) == ERROR) return ERROR;
      I2C1->DR = data[i];
    }
  
    if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;
  
    I2C1->CR1 = I2C_CR1_STOP | I2C_CR1_ACK | I2C_CR1_PE;
    return (ErrorStatus)(I2C1->SR1 & I2C_ERROR);
  }
  
  
  __STATIC_INLINE ErrorStatus i2c_read(const char addr, volatile char *data, unsigned len) {
  
    I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE;
    if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;
  
    I2C1->DR = (char)(addr << 1) + 1;
    if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;
    if (len == 1) I2C1->CR1 = I2C_CR1_PE;                 /* reset ACK bit              */
  
    (void) I2C1->SR2;
  
    for(unsigned i = 0; i < len; i++) {
      if (i == len - 1) I2C1->CR1 = I2C_CR1_PE;           /* reset ACK bit              */
      if (i2c_check(I2C_SR1_RXNE) == ERROR) return ERROR;
      data[i] = (char) I2C1->DR;
    }
  
    if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;
    I2C1->CR1 = I2C_CR1_STOP | I2C_CR1_ACK | I2C_CR1_PE;
  
    return (ErrorStatus)(I2C1->SR1 & I2C_ERROR);
  }
  
  __STATIC_INLINE ErrorStatus i2c_read_reg(const char addr, char *data, char reg, unsigned len) {
    I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE; /* generate START             */
    if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;
  
    I2C1->DR = (unsigned) addr << 1;                      /* send slave address         */
    if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;
  
    (void) I2C1->SR2;                                     /* dummy read status register */
    if (i2c_check(I2C_SR1_TXE) == ERROR) return ERROR;
  
    I2C1->DR = reg;                                       /* send register number       */
    if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;
  
    I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE; /* generate RE-START          */
    if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;
  
    I2C1->DR = (char)(addr << 1) + 1;                     /* send slave addr + read req */
    if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;
  
    if (len == 1) I2C1->CR1 = I2C_CR1_PE;                 /* reset ACK bit              */
  
    (void) I2C1->SR2;                                     /* dummy read status register */
  
    for(unsigned i = 0; i < len; i++) {
      if (i == len - 1) I2C1->CR1 = I2C_CR1_PE;           /* reset ACK bit              */
      if (i2c_check(I2C_SR1_RXNE) == ERROR) return ERROR;
      data[i] = (char) I2C1->DR;                          /* store received data        */
    }
  
    if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;
    I2C1->CR1 = I2C_CR1_STOP | I2C_CR1_ACK | I2C_CR1_PE;  /* generate STOP              */
  
    return (ErrorStatus)(I2C1->SR1 & I2C_ERROR);
  }
#endif

#ifdef __cplusplus
}
#endif

#endif /* __MAIN_H */
MAIN_H

#
# generate main.c
#

cat <<MAIN_C >main.c
#include <stdlib.h>
#include <stdio.h>
#include "main.h"

#if I2C_EN
  unsigned short i2c_status;
#endif

#if BTN_EN
  static volatile unsigned key_state;
#endif

int main(void) {

  init();

  for(;;) {

    #if USART_EN || SPI_EN || I2C_EN
      char pbuf[160];
      int offs = snprintf(pbuf, sizeof(pbuf), "Test #0x%02X", rand() % 0xFF);
    #endif

    #if I2C_EN
      char x[10] = {0};
      i2c_read_reg(0x68, x, 0, sizeof(x));  /* Read DS1307/DS3231 register pool */
      if (i2c_status == 0) {
        offs += snprintf((char*)&pbuf[offs], sizeof(pbuf) - (unsigned) offs, "; I2C: %02X:%02X:%02X", x[2], x[1], x[0]);
      } else {
        offs += snprintf((char*)&pbuf[offs], sizeof(pbuf) - (unsigned) offs, "; I2C ERR: %04X", i2c_status);
      }
    #endif

    #if SPI_EN
      CS_LOW();
      spi_xfer(0x00);
      char y = spi_xfer(0xFF);
      CS_HIGH();
      offs += snprintf((char*)&pbuf[offs], sizeof(pbuf) - (unsigned) offs, "; SPI: 0x%02X", y);
    #endif

    #if BTN_EN
      offs += snprintf((char*)&pbuf[offs], sizeof(pbuf) - (unsigned) offs, "; KEY: %s/%s", (key_state & (1 << 16)) ? "ON" : "OFF", (key_state & (2 << 16)) ? "ON" : "OFF");
      key_state &= (unsigned)~((1 << 16) | (2 << 16));
    #endif

    #if USART_EN
      offs += snprintf((char*)&pbuf[offs], sizeof(pbuf) - (unsigned) offs, "\n");
      uputs(pbuf);
    #endif

    DELAY_MS(1000);
  }

  return 0;
}


void SysTick_Handler(void) {
  static unsigned t_cnt;
  if (++t_cnt == 1000) { t_cnt = 0; }         /* Count to 1000 then reset */
  GPIOC->BSRR = GPIO_BSRR_BR13 * ((t_cnt == 970) || (t_cnt == 910) || (t_cnt == 850));
  GPIOC->BSRR = GPIO_BSRR_BS13 * ((t_cnt == 940) || (t_cnt == 880) || (t_cnt == 0));

  #if BTN_EN
    enum {CURRENT = 0, PREVIOUS = 1, TOTAL = 2};
    static unsigned btn[TOTAL][TOTAL];

    btn[0][CURRENT] <<= 1;
    btn[0][CURRENT] |= (READ_PIN(B, 0) == 0);
    btn[1][CURRENT] <<= 1;
    btn[1][CURRENT] |= (READ_PIN(B, 1) == 0);

    if ((btn[0][CURRENT] == 0xFFFFFFFF) && (btn[0][PREVIOUS] != 0xFFFFFFFF)) {
    	key_state |= (1 << 0);
    }
    if ((btn[1][CURRENT] == 0xFFFFFFFF) && (btn[1][PREVIOUS] != 0xFFFFFFFF)) {
    	key_state |= (1 << 1);
    }
    if ((btn[0][CURRENT] == 0) && (btn[0][PREVIOUS] != 0)) {
    	key_state |= (1 << 16);
    }
    if ((btn[1][CURRENT] == 0) && (btn[1][PREVIOUS] != 0)) {
    	key_state |= (1 << 17);
    }
    btn[0][PREVIOUS] = btn[0][CURRENT];
    btn[1][PREVIOUS] = btn[1][CURRENT];
  #endif
}

MAIN_C

#
# generate Makefile
#

cat <<MAKEFILE >Makefile
TARGET = project
BUILD_DIR = build

SRC = main.c system_stm32f1xx.c
ASM = startup_stm32f103xb.s
MCU = -mcpu=cortex-m3 -mthumb
DEF = -DSTM32F103xB
INC = -I.
OPT = -O3 -g0 -flto

ifdef GCC_PATH
  TOOLCHAIN = \$(GCC_PATH)/arm-none-eabi-
else
  TOOLCHAIN = arm-none-eabi-
endif

CC = \$(TOOLCHAIN)gcc
AS = \$(TOOLCHAIN)gcc -x assembler-with-cpp
CP = \$(TOOLCHAIN)objcopy
SZ = \$(TOOLCHAIN)size

HEX = \$(CP) -O ihex
BIN = \$(CP) -O binary -S

FLAG = \$(MCU) \$(DEF) \$(INC) -Wall -Werror -Wextra -Wpedantic -fdata-sections -ffunction-sections -std=gnu11

FLAG += -MMD -MP -MF"\$(@:%.o=%.d)"

ifeq (\$(OS), Windows_NT)

    FLAG += -D WIN32
    ifeq (\$(PROCESSOR_ARCHITEW6432), AMD64)
        FLAG += -D AMD64
    else
        ifeq (\$(PROCESSOR_ARCHITECTURE), AMD64)
            FLAG += -D AMD64
        endif
        ifeq (\$(PROCESSOR_ARCHITECTURE), x86)
            FLAG += -D IA32
        endif
    endif

    STLINK = ST-LINK_CLI.exe
    STLINK_FLAGS = -c UR -V -P \$(BUILD_DIR)/\$(TARGET).hex -HardRst -Run

else

    UNAME_S := \$(shell uname -s)
    ifeq (\$(UNAME_S), Linux)
        FLAGS += -D LINUX
    endif
    ifeq (\$(UNAME_S), Darwin)
        FLAGS += -D OSX
    endif
    UNAME_P := \$(shell uname -p)
    ifeq (\$(UNAME_P), x86_64)
        FLAGS += -D AMD64
    endif
    ifneq (\$(filter %86, \$(UNAME_P)),)
        FLAGS += -D IA32
    endif
    ifneq (\$(filter arm%, \$(UNAME_P)),)
        FLAGS += -D ARM
    endif

    STLINK = st-flash
    STLINK_FLAGS = --reset --format ihex write \$(BUILD_DIR)/\$(TARGET).hex

endif

LIB = -lc -lm -lnosys
LDSCRIPT = STM32F103XB_FLASH.ld
LDFLAGS = \$(MCU) -specs=nano.specs -T\$(LDSCRIPT) \$(LIB) -Wl,-Map=\$(BUILD_DIR)/\$(TARGET).map,--cref -Wl,--gc-sections

all: \$(BUILD_DIR)/\$(TARGET).elf \$(BUILD_DIR)/\$(TARGET).hex \$(BUILD_DIR)/\$(TARGET).bin

OBJ = \$(addprefix \$(BUILD_DIR)/,\$(notdir \$(SRC:.c=.o)))
vpath %.c \$(sort \$(dir \$(SRC)))

OBJ += \$(addprefix \$(BUILD_DIR)/,\$(notdir \$(ASM:.s=.o)))
vpath %.s \$(sort \$(dir \$(ASM)))

\$(BUILD_DIR)/%.o: %.c Makefile | \$(BUILD_DIR)
	\$(CC) -c \$(FLAG) \$(OPT) \$(EXT) \$< -o \$@

\$(BUILD_DIR)/%.o: %.s Makefile | \$(BUILD_DIR)
	\$(AS) -c \$(FLAG) \$(OPT) \$(EXT) -Wa,-a,-ad,-alms=\$(BUILD_DIR)/\$(notdir \$(<:.c=.lst)) \$< -o \$@

\$(BUILD_DIR)/\$(TARGET).elf: \$(OBJ) Makefile
	\$(CC) \$(OBJ) \$(LDFLAGS) \$(OPT) \$(EXT) -o \$@
	\$(SZ) \$@

\$(BUILD_DIR)/%.hex: \$(BUILD_DIR)/%.elf | \$(BUILD_DIR)
	\$(HEX) \$< \$@
	
\$(BUILD_DIR)/%.bin: \$(BUILD_DIR)/%.elf | \$(BUILD_DIR)
	\$(BIN) \$< \$@
	
\$(BUILD_DIR):
	mkdir \$@

debug: OPT = -Og -g -gdwarf
debug: FLAG += -DUSE_SWD=1
debug: all

# Display compiler version information.
gccversion :
	@\$(CC) --version

# Program the device.  
program: \$(BUILD_DIR)/\$(TARGET).hex
	\$(STLINK) \$(STLINK_FLAGS)

clean:
	rm -fR \$(BUILD_DIR)

-include \$(wildcard \$(BUILD_DIR)/*.d)

# *** EOF ***
MAKEFILE

cat <<DEBUG_JLINK >project.jdebug
void OnProjectLoad (void) {
  Project.SetDevice ("STM32F103C8");
  Project.SetHostIF ("USB", "");
  Project.SetTargetIF ("SWD");
  Project.SetTIFSpeed ("4 MHz");
  Project.AddSvdFile ("\$(InstallDir)/Config/CPU/Cortex-M3.svd");
  Project.AddSvdFile ("STM32F103xx.svd");
  File.Open ("build/project.elf");
}

void AfterTargetReset (void) {
  _SetupTarget();
}

void AfterTargetDownload (void) {
  _SetupTarget();
}

void _SetupTarget(void) {
  unsigned int SP;
  unsigned int PC;
  unsigned int VectorTableAddr;

  VectorTableAddr = Elf.GetBaseAddr();

  SP = Target.ReadU32(VectorTableAddr);
  if (SP != 0xFFFFFFFF) {
    Target.SetReg("SP", SP);
  }

  PC = Elf.GetEntryPointPC();
  if (PC != 0xFFFFFFFF) {
    Target.SetReg("PC", PC);
  } else {
    Util.Error("Project script error: failed to set up entry point PC", 1);
  }
}
DEBUG_JLINK

#
# run 'make' utility
#

make

echo
echo "type \"make program\" to download the firmware into the chip."
