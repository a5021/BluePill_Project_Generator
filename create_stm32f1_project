#!/bin/sh

if [ "$1" = "--help" ]
  then 
      echo ""
      echo "    STM32F1 Project Creator v0.01 ALPHA";
      echo "wget, st-utility and GNU Arm Embedded Toolchain are required"
      exit
fi


wg="wget -c"
cmsis="https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF1/master/Drivers/CMSIS/Include"
f1="https://raw.githubusercontent.com/STMicroelectronics/cmsis_device_f1/master"
svd="https://raw.githubusercontent.com/posborne/cmsis-svd/master/data/STMicro/STM32F103xx.svd"

$wg $cmsis/cmsis_compiler.h $cmsis/cmsis_armclang.h $cmsis/cmsis_gcc.h $cmsis/cmsis_version.h $cmsis/core_cm3.h \
    $f1/Include/stm32f1xx.h $f1/Include/stm32f103xb.h $f1/Include/system_stm32f1xx.h $f1/Source/Templates/system_stm32f1xx.c \
    $f1/Source/Templates/gcc/startup_stm32f103xb.s $f1/Source/Templates/gcc/linker/STM32F103XB_FLASH.ld $svd

#
# generate main.h
#

cat <<MAIN_H >main.h
#ifndef __MAIN_H
#define __MAIN_H

#include "stm32f1xx.h"

#ifdef __cplusplus
 extern C {
#endif

/* *********************************************************************************** */
/* ******** Uncomment lines below if these features are required ********************* */
/* *********************************************************************************** */
#if 0
  #define USE_HSE                       1  /* Use crystall oscillator as clock source  */
  #define USE_PLL                       1  /* Use PLL as system clock source           */
  #define USE_USART                     1  /* Configure USART1 for send and receive    */
  #define USE_I2C                       1  /* Configure I2C1 100kHz                    */
  #define USE_SPI                       1  /* Configure SPI1                           */
  #define USE_SWD                       1  /* Use SWD pins for debugging               */
#endif
/* *********************************************************************************** */
/* ********  or force using them while running make utility  ************************* */
/* *********************************************************************************** */


#define PORT_CFG(PORT, CFG)             *(__IO uint64_t*) GPIO ## PORT ## _BASE = (CFG)
#define PIN_CFG(PIN, MODE)              ((MODE) << ((PIN) * 4))
                                                                                       /*
    In input mode (MODE[1:0] = 00):

  00: Analog mode
  01: Floating input (reset state)
  10: Input with pull-up / pull-down
  11: Reserved
                                                                                       */
#define I_ANALOG                        (0ULL << 2)
#define I_FLOAT                         (1ULL << 2)
#define I_PULL                          (2ULL << 2)
                                                                                       /*
    In output mode (MODE[1:0] > 00):

  00: General purpose output push-pull
  01: General purpose output Open-drain
  10: Alternate function output Push-pull
  11: Alternate function output Open-drain
                                                                                       */
#define O_PP                            (0ULL << 2)
#define O_OD                            (1ULL << 2)
#define O_AF                            (2ULL << 2)
                                                                                       /*
  MODEy[1:0]: Port x mode bits (y = 0 .. 7)
  These bits are written by software to configure the corresponding I/O port.
  Refer to Table 20: Port bit configuration table.

  00: Input mode (reset state)
  01: Output mode, max speed 10 MHz.
  10: Output mode, max speed 2 MHz.
  11: Output mode, max speed 50 MHz.
                                                                                       */
#define O_10MHZ                         1ULL
#define O_2MHZ                          2ULL
#define O_50MHZ                         3ULL

#define DOWN                            GPIO_BSRR_BR
#define UP                              GPIO_BSRR_BS

#define CAT(A, B)                       A ## B
#define SW_PIN(PORT, PIN, STATE)        GPIO ## PORT->BSRR = CAT(STATE, PIN)
#define PULL(PIN, STATE)                CAT(STATE, PIN)
#define HIGH(PIN)                       GPIO_BSRR_BS ## PIN
#define LOW(PIN)                        GPIO_BSRR_BR ## PIN

#define ATOMIC_OUT(PORT, DATA)          PORT->BSRR = 0x00FF0000 | (DATA)
#define READ_PIN(PORT, PIN)             (GPIO ## PORT->IDR & GPIO_IDR_IDR ## PIN)

#define GET_TICK()                      (SysTick->CTRL >> SysTick_CTRL_COUNTFLAG_Pos)
#define DELAY_MS(MS)                    do {(void)SysTick->CTRL; for(unsigned _ = MS; _; _ -= GET_TICK()) {}}while(0)

     /* I2C bus speed  */

#if defined(USE_SWD) && (USE_SWD != 0)
  #define SWD_EN                        1
#else
  #define SWD_EN                        0
#endif

#if defined(USE_USART) && (USE_USART != 0)
  #define USART_EN                      1
#else
  #define USART_EN                      0
#endif

#if defined(USE_I2C) && (USE_I2C != 0)
  #define I2C_EN                        1
  #define I2C_SPEED_STANDARD            100000
  #define I2C_SPEED_FAST                400000

  #if 0
    #define I2C_SPEED_MODE              I2C_SPEED_STANDARD
  #else
    #define I2C_SPEED_MODE              I2C_SPEED_FAST
  #endif

  #define I2C_DUTY_CYCLE_2              0x00000000U                      /* I2C fast mode Tlow/Thigh = 2        */
  #define I2C_DUTY_CYCLE_16_9           I2C_CCR_DUTY                     /* I2C fast mode Tlow/Thigh = 16/9     */

  #define I2C_CONFIGURE_CCR(APB1_CLOCK, I2C_SPEED)                       (uint32_t)(((I2C_SPEED) <= I2C_SPEED_STANDARD)? \
                                                                         (I2C_CONFIGURE_CCR_STANDARD((APB1_CLOCK), (I2C_SPEED))) : \
                                                                         (I2C_CONFIGURE_CCR_FAST((APB1_CLOCK), (I2C_SPEED), (I2C_DUTY_CYCLE_2))))

  #define I2C_CONFIGURE_CCR_STANDARD(APB1_CLOCK, I2C_SPEED)              (uint32_t)(((((APB1_CLOCK)/((I2C_SPEED) << 1U)) & I2C_CCR_CCR) < 4U) ? 4U:((APB1_CLOCK) / ((I2C_SPEED) << 1U)))

  #define I2C_CONFIGURE_CCR_FAST(APB1_CLOCK, I2C_SPEED, I2C_DUTY_CYCLE)  (uint32_t)(((I2C_DUTY_CYCLE) == I2C_DUTY_CYCLE_2) ? \
                                                                         (((((APB1_CLOCK) / ((I2C_SPEED) * 3U)) & I2C_CCR_CCR) == 0U) ? 1U:((APB1_CLOCK) / ((I2C_SPEED) * 3U))) : \
                                                                         (((((APB1_CLOCK) / ((I2C_SPEED) * 25U)) & I2C_CCR_CCR) == 0U) ? 1U:((APB1_CLOCK) / ((I2C_SPEED) * 25U))))

  #define I2C_RISE_TIME(APB1_CLOCK, I2C_SPEED)                           (uint32_t)(((I2C_SPEED) <= I2C_SPEED_STANDARD) ? ((APB1_CLOCK) / 1000000 + 1) : ((((APB1_CLOCK) / 1000000) * 300) / 1000) + 1)
#else
  #define I2C_EN                        0
#endif

#if defined(USE_SPI) && (USE_SPI != 0)
  #define SPI_EN                        1
#else
  #define SPI_EN                        0
#endif


__STATIC_INLINE void init(void) {

  RCC->APB2ENR = (

    #if USART_EN
      RCC_APB2ENR_USART1EN        |                           /* Enable clock for USART1            */
      RCC_APB2ENR_IOPAEN          |                           /* Enable clock for GPIOA             */
    #endif

    #if SPI_EN
      RCC_APB2ENR_IOPAEN          |                           /* Enable clock for GPIOA             */
      RCC_APB2ENR_SPI1EN          |                           /* Enable clock for SPI1              */
    #endif

    #if I2C_EN
      RCC_APB2ENR_IOPBEN          |                           /* Enable clock for GPIOB             */
    #endif

    RCC_APB2ENR_AFIOEN            |                           /* Enable clock for AFIO              */

    #if SWD_EN
      RCC_APB2ENR_IOPAEN          |                           /* Enable clock for GPIOA             */
    #endif

    RCC_APB2ENR_IOPCEN                                        /* Enable clock for GPIOC             */
  );

  #if I2C_EN

    RCC->APB1ENR = (
      I2C_EN * RCC_APB1ENR_I2C1EN                             /* Enable clock for I2C1              */
    );

    PORT_CFG(B, 
      I2C_EN   * PIN_CFG(6,  O_AF + O_OD)    |                /* PB6:  I2C1 SCL, altern, open drain */
      I2C_EN   * PIN_CFG(7,  O_AF + O_OD)                     /* PA7:  I2C1 SDA, altern, open drain */
    );

  #endif

  PORT_CFG(C, PIN_CFG(13, O_2MHZ));                           /* PC13: output, push-pull, 2Mhz      */
  SW_PIN(C, 13, UP);                                          /* Set PC13 pin HIGH (LED off)        */

  #if USART_EN || SWD_EN || SPI_EN

    PORT_CFG(A, 
      SPI_EN   * PIN_CFG(4,  O_10MHZ)        |                /* PA4:  SPI1 CS, output, 10MHz       */
      SPI_EN   * PIN_CFG(5,  O_AF + O_50MHZ) |                /* PA5:  SPI1 CLK, alternate, 50MHz   */
      SPI_EN   * PIN_CFG(6,  I_PULL)         |                /* PA6:  SPI1 MISO, input, pull-down  */
      SPI_EN   * PIN_CFG(7,  O_AF + O_50MHZ) |                /* PA7:  SPI1 MOSI, alternate, 50MHz  */
      USART_EN * PIN_CFG(9,  O_AF + O_10MHZ) |                /* PA9:  USART1 TX, alternate, 10MHz  */
      USART_EN * PIN_CFG(10, I_PULL)         |                /* PA10: USART1 RX, input, pull-down  */
      SWD_EN   * PIN_CFG(13, I_PULL)         |                /* PA13: SWDIO, input, pull-up        */
      SWD_EN   * PIN_CFG(14, I_PULL)                          /* PA14: SWCLK, input, pull-down      */
    );

    GPIOA->BSRR = (
      SPI_EN   * PULL(6,  DOWN) |                             /* Pull-down SPI1 MISO pin            */
      USART_EN * PULL(10, DOWN) |                             /* Pull-down USART1 RX pin            */
      SWD_EN   * PULL(13, UP)   |                             /* Pull-up SWDIO pin                  */
      SWD_EN   * PULL(14, DOWN)                               /* Pull-down SWCLK pin                */
    );

  #endif

  #if SWD_EN
    AFIO->MAPR = AFIO_MAPR_SWJ_CFG_JTAGDISABLE;               /* Disable JTAG, enable SWD           */
  #else
    AFIO->MAPR = AFIO_MAPR_SWJ_CFG_DISABLE;                   /* Disable both JTAG and SWD          */
  #endif

  #if defined USE_HSE && USE_HSE != 0

    RCC->CR = RCC_CR_HSEON;                                   /* Switch HSE on                      */
    while((RCC->CR & RCC_CR_HSERDY) == 0) {/* NO OP */}       /* Wait until HSE becomes ready       */

    #define RCC_CFGR RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL9      /* 72 MHz: PllSrc = HSE, Mul = 9      */
    #define RCC_CR   RCC_CR_PLLON | RCC_CR_HSEON
    #define HCLK     72000000UL

  #else

    #define RCC_CFGR RCC_CFGR_PLLMULL16                       /* 64 MHz: PllSrc = HSI / 2, Mul = 16 */
    #define RCC_CR   RCC_CR_PLLON
    #define HCLK     64000000UL

  #endif

  #if defined USE_PLL && USE_PLL != 0

    RCC->CFGR = RCC_CFGR;                                     /* Configure PLL                      */
    RCC->CR = RCC_CR;                                         /* Switch PLL on                      */
    while((RCC->CR & RCC_CR_PLLRDY) == 0) { /* NO OP */}      /* Wait until PLL becomes ready       */
    FLASH->ACR = FLASH_ACR_LATENCY_1;                         /* Set flash latency to 2             */
    RCC->CFGR = (
      RCC_CFGR_SW_PLL      |                                  /* Set PLL as system clock source     */
      RCC_CFGR_PPRE1_DIV2                                     /* Set APB1 clock as HCLK / 2         */
    );

    #define APB1_CLK ((HCLK) / 2)

  #else

    #undef  HCLK
    #define HCLK     8000000UL
    #define APB1_CLK HCLK

  #endif

  SysTick->LOAD = HCLK / 8000 - 1;                            /* Set SysTick reload register        */
  SysTick->CTRL = SysTick_CTRL_ENABLE_Msk |                   /* Start SysTick timer (HCLK / 8)     */
                  SysTick_CTRL_TICKINT_Msk;

  #if USART_EN
    #define BAUDRATE 115200

    USART1->BRR = (HCLK + BAUDRATE / 2) / BAUDRATE;           /* Configure USART baud rate          */
    USART1->CR1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_UE; /* Enable USART peripheral            */

  #endif

  #if I2C_EN
    I2C1->CCR = I2C_CONFIGURE_CCR(APB1_CLK, I2C_SPEED_MODE); /* Write CCR only when I2C is disabled */
    I2C1->TRISE = I2C_RISE_TIME(APB1_CLK, I2C_SPEED_MODE);   /* Maximum rise time in Fm/Sm mode     */
    I2C1->CR2 = APB1_CLK / 1000000;                          /* Configure Peripheral Clock Freq.    */
    I2C1->CR1 = I2C_CR1_PE;                                  /* Enable Peripheral                   */
  #endif

}

#if USART_EN
  __STATIC_INLINE void uputc(char c) {
    while (!(USART1->SR & USART_SR_TXE)) { /* JUST WAIT */ }  /* Wait until TX becomes empty        */
    USART1->DR = c;
  }

  __STATIC_INLINE void uputs(char *c) {
    while(*c) {
      uputc(*c++);
    }
  }
  
  #define HEX(NIBBLE) (((NIBBLE) < 10) ? (NIBBLE) + '0' : (NIBBLE) + '7')
  
    /* Convert a nibble to HEX and send it via UART */
  __STATIC_INLINE void uput_x(const uint8_t c) {
    /* Convert a nibble to HEX char and send it via UART */
    uputc(HEX(c));
  }

    /* Convert a byte to HEX and send it via UART */
  __STATIC_INLINE void uputx(const uint8_t c) {
    uput_x(c >> 4);
    uput_x(c & 0x0F);
  }
  
  #define uprintf(...) do{char _[160]; snprintf(_, sizeof(_), __VA_ARGS__); uputs(_);}while(0)
  
#endif

#if I2C_EN

  #define I2C_TIMEOUT                   10
  #define I2C_ERR_TIMEOUT               1
  #define I2C_ERROR                     (                                                            \
                                          I2C_SR1_BERR  |  /*  Bus Error            (0x00000100)   */\
                                          I2C_SR1_ARLO  |  /*  Arbitration Lost     (0x00000200)   */\
                                          I2C_SR1_AF    |  /*  Acknowledge Failure  (0x00000400)   */\
                                          I2C_SR1_OVR      /*  Overrun/Underrun     (0x00000800)   */\
                                        )

extern unsigned short i2c_status;

__STATIC_INLINE ErrorStatus i2c_check(const unsigned bitFlag) {
  unsigned t_out = I2C_TIMEOUT;
  (void) SysTick->CTRL;

  while((I2C1->SR1 & bitFlag) == 0) {
    t_out -= SysTick->CTRL >> SysTick_CTRL_COUNTFLAG_Pos;
    if (t_out == 0) {
      i2c_status |= I2C_ERR_TIMEOUT;
      return ERROR;
    }

    unsigned e_status = I2C1->SR1 & I2C_ERROR;
    if (e_status) {
      i2c_status = (unsigned short)e_status;
      return ERROR;
    }
  }

  return SUCCESS;
}


__STATIC_INLINE ErrorStatus i2c_write(const char addr, const char *data, unsigned len) {
  I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE;
  if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;

  I2C1->DR = (unsigned) addr << 1;
  if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;

  (void) I2C1->SR2;

  for(unsigned i = 0; i < len; i++) {
    if (i2c_check(I2C_SR1_TXE) == ERROR) return ERROR;
    I2C1->DR = data[i];
  }

  if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;

  I2C1->CR1 = I2C_CR1_STOP | I2C_CR1_ACK | I2C_CR1_PE;
  return (ErrorStatus)(I2C1->SR1 & I2C_ERROR);
}


__STATIC_INLINE ErrorStatus i2c_read(const char addr, volatile char *data, unsigned len) {

  I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE;
  if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;

  I2C1->DR = (char)(addr << 1) + 1;
  if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;
  if (len == 1) I2C1->CR1 = I2C_CR1_PE;                 /* reset ACK bit              */

  (void) I2C1->SR2;

  for(unsigned i = 0; i < len; i++) {
    if (i == len - 1) I2C1->CR1 = I2C_CR1_PE;           /* reset ACK bit              */
    if (i2c_check(I2C_SR1_RXNE) == ERROR) return ERROR;
    data[i] = (char) I2C1->DR;
  }

  if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;
  I2C1->CR1 = I2C_CR1_STOP | I2C_CR1_ACK | I2C_CR1_PE;

  return (ErrorStatus)(I2C1->SR1 & I2C_ERROR);
}

__STATIC_INLINE ErrorStatus i2c_read_reg(const char addr, char *data, char reg, unsigned len) {
  I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE; /* generate START             */
  if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;

  I2C1->DR = (unsigned) addr << 1;                      /* send slave address         */
  if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;

  (void) I2C1->SR2;                                     /* dummy read status register */
  if (i2c_check(I2C_SR1_TXE) == ERROR) return ERROR;

  I2C1->DR = reg;                                       /* send register number       */
  if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;

  I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE; /* generate RE-START          */
  if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;

  I2C1->DR = (char)(addr << 1) + 1;                     /* send slave addr + read req */
  if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;

  if (len == 1) I2C1->CR1 = I2C_CR1_PE;                 /* reset ACK bit              */

  (void) I2C1->SR2;                                     /* dummy read status register */

  for(unsigned i = 0; i < len; i++) {
    if (i == len - 1) I2C1->CR1 = I2C_CR1_PE;           /* reset ACK bit              */
    if (i2c_check(I2C_SR1_RXNE) == ERROR) return ERROR;
    data[i] = (char) I2C1->DR;                          /* store received data        */
  }

  if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;
  I2C1->CR1 = I2C_CR1_STOP | I2C_CR1_ACK | I2C_CR1_PE;  /* generate STOP              */

  return (ErrorStatus)(I2C1->SR1 & I2C_ERROR);
}
#endif

#ifdef __cplusplus
}
#endif

#endif /* __MAIN_H */
MAIN_H

#
# generate main.c
#

cat <<MAIN_C >main.c
#include <stdlib.h>
#include <stdio.h>
#include "main.h"

#if I2C_EN
  unsigned short i2c_status;
#endif

int main(void) {

  init();

  for(;;) {

    #if USART_EN
      uprintf("Just a test. Magic code is 0x%04X\n", rand() % 0xFFFF);
    #endif

    #if I2C_EN
      char buf[10];
      i2c_read_reg(0x78, buf, 0, 1);
      if (i2c_status != 0) {
        /* just check */
      }
    #endif

    DELAY_MS(1000);
  }

  return 0;
}


void SysTick_Handler(void) {
  static unsigned t_cnt;
  if (++t_cnt == 1000) {
    t_cnt = 0;
  } 
  GPIOC->BSRR = GPIO_BSRR_BR13 * ((t_cnt == 970) || (t_cnt == 910) || (t_cnt == 850));
  GPIOC->BSRR = GPIO_BSRR_BS13 * ((t_cnt == 940) || (t_cnt == 880) || (t_cnt == 0));
}

MAIN_C

#
# generate Makefile
#

cat <<MAKEFILE >Makefile
TARGET = project
BUILD_DIR = build

SRC = main.c system_stm32f1xx.c
ASM = startup_stm32f103xb.s
MCU = -mcpu=cortex-m3 -mthumb
DEF = -DSTM32F103xB
INC = -I.
OPT = -O3 -g0 -flto

ifdef GCC_PATH
  TOOLCHAIN = \$(GCC_PATH)/arm-none-eabi-
else
  TOOLCHAIN = arm-none-eabi-
endif

CC = \$(TOOLCHAIN)gcc
AS = \$(TOOLCHAIN)gcc -x assembler-with-cpp
CP = \$(TOOLCHAIN)objcopy
SZ = \$(TOOLCHAIN)size

HEX = \$(CP) -O ihex
BIN = \$(CP) -O binary -S

FLAG = \$(MCU) \$(DEF) \$(INC) -Wall -Werror -Wextra -Wpedantic -fdata-sections -ffunction-sections -std=gnu11

FLAG += -MMD -MP -MF"\$(@:%.o=%.d)"

ifeq (\$(OS), Windows_NT)

    FLAG += -D WIN32
    ifeq (\$(PROCESSOR_ARCHITEW6432), AMD64)
        FLAG += -D AMD64
    else
        ifeq (\$(PROCESSOR_ARCHITECTURE), AMD64)
            FLAG += -D AMD64
        endif
        ifeq (\$(PROCESSOR_ARCHITECTURE), x86)
            FLAG += -D IA32
        endif
    endif

    STLINK = ST-LINK_CLI.exe
    STLINK_FLAGS = -c UR -V -P \$(BUILD_DIR)/\$(TARGET).hex -HardRst -Run

else

    UNAME_S := \$(shell uname -s)
    ifeq (\$(UNAME_S), Linux)
        FLAGS += -D LINUX
    endif
    ifeq (\$(UNAME_S), Darwin)
        FLAGS += -D OSX
    endif
    UNAME_P := \$(shell uname -p)
    ifeq (\$(UNAME_P), x86_64)
        FLAGS += -D AMD64
    endif
    ifneq (\$(filter %86, \$(UNAME_P)),)
        FLAGS += -D IA32
    endif
    ifneq (\$(filter arm%, \$(UNAME_P)),)
        FLAGS += -D ARM
    endif

    STLINK = st-flash
    STLINK_FLAGS = --reset --format ihex write \$(BUILD_DIR)/\$(TARGET).hex

endif

LIB = -lc -lm -lnosys
LDSCRIPT = STM32F103XB_FLASH.ld
LDFLAGS = \$(MCU) -specs=nano.specs -T\$(LDSCRIPT) \$(LIB) -Wl,-Map=\$(BUILD_DIR)/\$(TARGET).map,--cref -Wl,--gc-sections

all: \$(BUILD_DIR)/\$(TARGET).elf \$(BUILD_DIR)/\$(TARGET).hex \$(BUILD_DIR)/\$(TARGET).bin

OBJ = \$(addprefix \$(BUILD_DIR)/,\$(notdir \$(SRC:.c=.o)))
vpath %.c \$(sort \$(dir \$(SRC)))

OBJ += \$(addprefix \$(BUILD_DIR)/,\$(notdir \$(ASM:.s=.o)))
vpath %.s \$(sort \$(dir \$(ASM)))

\$(BUILD_DIR)/%.o: %.c Makefile | \$(BUILD_DIR)
	\$(CC) -c \$(FLAG) \$(OPT) \$(EXT) \$< -o \$@

\$(BUILD_DIR)/%.o: %.s Makefile | \$(BUILD_DIR)
	\$(AS) -c \$(FLAG) \$(OPT) \$(EXT) -Wa,-a,-ad,-alms=\$(BUILD_DIR)/\$(notdir \$(<:.c=.lst)) \$< -o \$@

\$(BUILD_DIR)/\$(TARGET).elf: \$(OBJ) Makefile
	\$(CC) \$(OBJ) \$(LDFLAGS) \$(OPT) \$(EXT) -o \$@
	\$(SZ) \$@

\$(BUILD_DIR)/%.hex: \$(BUILD_DIR)/%.elf | \$(BUILD_DIR)
	\$(HEX) \$< \$@
	
\$(BUILD_DIR)/%.bin: \$(BUILD_DIR)/%.elf | \$(BUILD_DIR)
	\$(BIN) \$< \$@
	
\$(BUILD_DIR):
	mkdir \$@

debug: OPT = -Og -g -gdwarf
debug: FLAG += -DUSE_SWD=1
debug: all

# Display compiler version information.
gccversion :
	@\$(CC) --version

# Program the device.  
program: \$(BUILD_DIR)/\$(TARGET).hex
	\$(STLINK) \$(STLINK_FLAGS)

clean:
	rm -fR \$(BUILD_DIR)

-include \$(wildcard \$(BUILD_DIR)/*.d)

# *** EOF ***
MAKEFILE

cat <<DEBUG_JLINK >project.jdebug
void OnProjectLoad (void) {
  Project.SetDevice ("STM32F103C8");
  Project.SetHostIF ("USB", "");
  Project.SetTargetIF ("SWD");
  Project.SetTIFSpeed ("4 MHz");
  Project.AddSvdFile ("\$(InstallDir)/Config/CPU/Cortex-M3.svd");
  Project.AddSvdFile ("STM32F103xx.svd");
  File.Open ("build/project.elf");
}

void AfterTargetReset (void) {
  _SetupTarget();
}

void AfterTargetDownload (void) {
  _SetupTarget();
}

void _SetupTarget(void) {
  unsigned int SP;
  unsigned int PC;
  unsigned int VectorTableAddr;

  VectorTableAddr = Elf.GetBaseAddr();

  SP = Target.ReadU32(VectorTableAddr);
  if (SP != 0xFFFFFFFF) {
    Target.SetReg("SP", SP);
  }

  PC = Elf.GetEntryPointPC();
  if (PC != 0xFFFFFFFF) {
    Target.SetReg("PC", PC);
  } else {
    Util.Error("Project script error: failed to set up entry point PC", 1);
  }
}
DEBUG_JLINK

#
# run 'make' utility
#

make

echo
echo "type \"make program\" to download the firmware into the chip."
