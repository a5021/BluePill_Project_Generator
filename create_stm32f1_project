#!/bin/sh

if [ "$1" = "--help" ]
  then
      echo ""
      echo "    STM32F1 Project Creator v0.02";
      echo "wget, st-utility and GNU Arm Embedded Toolchain are required"
      echo
      echo "Usage:"
      echo "        $0 [command] [command] ... [options] [options] ... "
      echo
      echo "Commands:"
      echo "        mdk  generate simple Keil MDK-ARM config"
      echo "        pdf  fetch stm32f10x reference manual (rm0008)"
      exit
fi


wg="wget -c"
raw=https://raw.githubusercontent.com
st=$raw/STMicroelectronics/
cmsis=$st/STM32CubeF1/master/Drivers/CMSIS/Include
f1=$st/cmsis_device_f1/master
svd="https://raw.githubusercontent.com/posborne/cmsis-svd/master/data/STMicro/STM32F103xx.svd"

$wg $cmsis/cmsis_compiler.h $cmsis/cmsis_gcc.h $cmsis/cmsis_version.h $cmsis/core_cm3.h \
    $f1/Include/stm32f1xx.h $f1/Include/stm32f103xb.h $f1/Include/system_stm32f1xx.h $f1/Source/Templates/system_stm32f1xx.c \
    $f1/Source/Templates/gcc/startup_stm32f103xb.s $f1/Source/Templates/gcc/linker/STM32F103XB_FLASH.ld $svd

if [ "$1" = "pdf" ] || [ "$2" = "pdf" ] || [ "$3" = "pdf" ] || [ "$4" = "pdf" ] || [ "$5" = "pdf" ] || [ "$6" = "pdf" ]
  then
      $wg https://www.st.com/resource/en/reference_manual/cd00171190-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf -O rm0008.pdf
      $wg https://www.st.com/resource/en/datasheet/stm32f103c8.pdf
fi

if [ "$1" = "mdk" ] || [ "$2" = "mdk" ] || [ "$3" = "mdk" ] || [ "$4" = "mdk" ] || [ "$5" = "mdk" ] || [ "$6" = "mdk" ]
  then
      $wg $cmsis/cmsis_armclang.h
      mkdir MDK-ARM
      cd MDK-ARM
      $wg $f1/Source/Templates/arm/startup_stm32f103xb.s
      def_set1="<Define>STM32F103xB,"
      def_set2="USE_HSE=0, USE_PLL=0, USE_USART=1, USE_I2C=0, USE_SPI=0, USE_RTC=0, USE_LSE=0, USE_BTN=0, USE_TIM2=0, USE_CRC=0, USE_ADC=0, USE_FLASH=0, USE_IWDG=0, USE_WWDG=0, USE_EXTI=0, USE_RNG=0</Define>"
      cat << MDK_CONFIG > project.uvprojx
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<Project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="project_projx.xsd">
  <SchemaVersion>2.1</SchemaVersion>
  <Header>### uVision Project, (C) Keil Software</Header>
  <Targets>
    <Target>
      <TargetName>Debug</TargetName>
      <ToolsetNumber>0x4</ToolsetNumber>
      <ToolsetName>ARM-ADS</ToolsetName>
      <pCCUsed>6160000::V6.16::ARMCLANG</pCCUsed>
      <uAC6>1</uAC6>
      <TargetOption>
        <TargetCommonOption>
          <Device>STM32F103CB</Device>
          <Vendor>STMicroelectronics</Vendor>
          <PackID>Keil.STM32F1xx_DFP.2.3.0</PackID>
          <PackURL>http://www.keil.com/pack/</PackURL>
          <Cpu>IRAM(0x20000000,0x00005000) IROM(0x08000000,0x00020000) CPUTYPE("Cortex-M3") CLOCK(8000000) ELITTLE</Cpu>
          <FlashUtilSpec></FlashUtilSpec>
          <StartupFile></StartupFile>
          <FlashDriverDll>UL2CM3(-S0 -C0 -P0 -FD20000000 -FC1000 -FN1 -FF0STM32F10x_128 -FS08000000 -FL020000 -FP0(195Device:STM32F103CB\STM32F10x_128.FLM))</FlashDriverDll>
          <DeviceId>0</DeviceId>
          <RegisterFile>195Device:STM32F103CB\Include\stm32f10x.h</RegisterFile>
          <MemoryEnv></MemoryEnv>
          <Cmp></Cmp>
          <Asm></Asm>
          <Linker></Linker>
          <OHString></OHString>
          <InfinionOptionDll></InfinionOptionDll>
          <SLE66CMisc></SLE66CMisc>
          <SLE66AMisc></SLE66AMisc>
          <SLE66LinkerMisc></SLE66LinkerMisc>
          <SFDFile>195Device:STM32F103CB\STM32F103xx.svd</SFDFile>
          <bCustSvd>0</bCustSvd>
          <UseEnv>0</UseEnv>
          <BinPath></BinPath>
          <IncludePath></IncludePath>
          <LibPath></LibPath>
          <RegisterFilePath></RegisterFilePath>
          <DBRegisterFilePath></DBRegisterFilePath>
          <TargetStatus>
            <Error>0</Error>
            <ExitCodeStop>0</ExitCodeStop>
            <ButtonStop>0</ButtonStop>
            <NotGenerated>0</NotGenerated>
            <InvalidFlash>1</InvalidFlash>
          </TargetStatus>
          <OutputDirectory>.\OUTPUT\</OutputDirectory>
          <OutputName>project</OutputName>
          <CreateExecutable>1</CreateExecutable>
          <CreateLib>0</CreateLib>
          <CreateHexFile>1</CreateHexFile>
          <DebugInformation>1</DebugInformation>
          <BrowseInformation>1</BrowseInformation>
          <ListingPath></ListingPath>
          <HexFormatSelection>1</HexFormatSelection>
          <Merge32K>0</Merge32K>
          <CreateBatchFile>0</CreateBatchFile>
          <BeforeCompile>
            <RunUserProg1>0</RunUserProg1>
            <RunUserProg2>0</RunUserProg2>
            <UserProg1Name></UserProg1Name>
            <UserProg2Name></UserProg2Name>
            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
            <nStopU1X>0</nStopU1X>
            <nStopU2X>0</nStopU2X>
          </BeforeCompile>
          <BeforeMake>
            <RunUserProg1>0</RunUserProg1>
            <RunUserProg2>0</RunUserProg2>
            <UserProg1Name></UserProg1Name>
            <UserProg2Name></UserProg2Name>
            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
            <nStopB1X>0</nStopB1X>
            <nStopB2X>0</nStopB2X>
          </BeforeMake>
          <AfterMake>
            <RunUserProg1>0</RunUserProg1>
            <RunUserProg2>0</RunUserProg2>
            <UserProg1Name></UserProg1Name>
            <UserProg2Name></UserProg2Name>
            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
            <nStopA1X>0</nStopA1X>
            <nStopA2X>0</nStopA2X>
          </AfterMake>
          <SelectedForBatchBuild>1</SelectedForBatchBuild>
          <SVCSIdString></SVCSIdString>
        </TargetCommonOption>
        <CommonProperty>
          <UseCPPCompiler>0</UseCPPCompiler>
          <RVCTCodeConst>0</RVCTCodeConst>
          <RVCTZI>0</RVCTZI>
          <RVCTOtherData>0</RVCTOtherData>
          <ModuleSelection>0</ModuleSelection>
          <IncludeInBuild>1</IncludeInBuild>
          <AlwaysBuild>0</AlwaysBuild>
          <GenerateAssemblyFile>0</GenerateAssemblyFile>
          <AssembleAssemblyFile>0</AssembleAssemblyFile>
          <PublicsOnly>0</PublicsOnly>
          <StopOnExitCode>3</StopOnExitCode>
          <CustomArgument></CustomArgument>
          <IncludeLibraryModules></IncludeLibraryModules>
          <ComprImg>0</ComprImg>
        </CommonProperty>
        <DllOption>
          <SimDllName>SARMCM3.DLL</SimDllName>
          <SimDllArguments> -REMAP</SimDllArguments>
          <SimDlgDll>DCM.DLL</SimDlgDll>
          <SimDlgDllArguments>-pCM3</SimDlgDllArguments>
          <TargetDllName>SARMCM3.DLL</TargetDllName>
          <TargetDllArguments></TargetDllArguments>
          <TargetDlgDll>TCM.DLL</TargetDlgDll>
          <TargetDlgDllArguments>-pCM3</TargetDlgDllArguments>
        </DllOption>
        <DebugOption>
          <OPTHX>
            <HexSelection>1</HexSelection>
            <HexRangeLowAddress>0</HexRangeLowAddress>
            <HexRangeHighAddress>0</HexRangeHighAddress>
            <HexOffset>0</HexOffset>
            <Oh166RecLen>16</Oh166RecLen>
          </OPTHX>
        </DebugOption>
        <Utilities>
          <Flash1>
            <UseTargetDll>1</UseTargetDll>
            <UseExternalTool>0</UseExternalTool>
            <RunIndependent>0</RunIndependent>
            <UpdateFlashBeforeDebugging>1</UpdateFlashBeforeDebugging>
            <Capability>1</Capability>
            <DriverSelection>4101</DriverSelection>
          </Flash1>
          <bUseTDR>1</bUseTDR>
          <Flash2>BIN\UL2CM3.DLL</Flash2>
          <Flash3></Flash3>
          <Flash4></Flash4>
          <pFcarmOut></pFcarmOut>
          <pFcarmGrp></pFcarmGrp>
          <pFcArmRoot></pFcArmRoot>
          <FcArmLst>0</FcArmLst>
        </Utilities>
        <TargetArmAds>
          <ArmAdsMisc>
            <GenerateListings>0</GenerateListings>
            <asHll>1</asHll>
            <asAsm>1</asAsm>
            <asMacX>1</asMacX>
            <asSyms>1</asSyms>
            <asFals>1</asFals>
            <asDbgD>1</asDbgD>
            <asForm>1</asForm>
            <ldLst>0</ldLst>
            <ldmm>1</ldmm>
            <ldXref>1</ldXref>
            <BigEnd>0</BigEnd>
            <AdsALst>1</AdsALst>
            <AdsACrf>1</AdsACrf>
            <AdsANop>0</AdsANop>
            <AdsANot>0</AdsANot>
            <AdsLLst>1</AdsLLst>
            <AdsLmap>1</AdsLmap>
            <AdsLcgr>1</AdsLcgr>
            <AdsLsym>1</AdsLsym>
            <AdsLszi>1</AdsLszi>
            <AdsLtoi>1</AdsLtoi>
            <AdsLsun>1</AdsLsun>
            <AdsLven>1</AdsLven>
            <AdsLsxf>1</AdsLsxf>
            <RvctClst>0</RvctClst>
            <GenPPlst>0</GenPPlst>
            <AdsCpuType>"Cortex-M3"</AdsCpuType>
            <RvctDeviceName></RvctDeviceName>
            <mOS>0</mOS>
            <uocRom>0</uocRom>
            <uocRam>0</uocRam>
            <hadIROM>1</hadIROM>
            <hadIRAM>1</hadIRAM>
            <hadXRAM>0</hadXRAM>
            <uocXRam>0</uocXRam>
            <RvdsVP>0</RvdsVP>
            <RvdsMve>0</RvdsMve>
            <RvdsCdeCp>0</RvdsCdeCp>
            <hadIRAM2>0</hadIRAM2>
            <hadIROM2>0</hadIROM2>
            <StupSel>8</StupSel>
            <useUlib>1</useUlib>
            <EndSel>0</EndSel>
            <uLtcg>0</uLtcg>
            <nSecure>0</nSecure>
            <RoSelD>3</RoSelD>
            <RwSelD>3</RwSelD>
            <CodeSel>0</CodeSel>
            <OptFeed>0</OptFeed>
            <NoZi1>0</NoZi1>
            <NoZi2>0</NoZi2>
            <NoZi3>0</NoZi3>
            <NoZi4>0</NoZi4>
            <NoZi5>0</NoZi5>
            <Ro1Chk>0</Ro1Chk>
            <Ro2Chk>0</Ro2Chk>
            <Ro3Chk>0</Ro3Chk>
            <Ir1Chk>1</Ir1Chk>
            <Ir2Chk>0</Ir2Chk>
            <Ra1Chk>0</Ra1Chk>
            <Ra2Chk>0</Ra2Chk>
            <Ra3Chk>0</Ra3Chk>
            <Im1Chk>1</Im1Chk>
            <Im2Chk>0</Im2Chk>
            <OnChipMemories>
              <Ocm1>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm1>
              <Ocm2>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm2>
              <Ocm3>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm3>
              <Ocm4>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm4>
              <Ocm5>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm5>
              <Ocm6>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm6>
              <IRAM>
                <Type>0</Type>
                <StartAddress>0x20000000</StartAddress>
                <Size>0x5000</Size>
              </IRAM>
              <IROM>
                <Type>1</Type>
                <StartAddress>0x8000000</StartAddress>
                <Size>0x20000</Size>
              </IROM>
              <XRAM>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </XRAM>
              <OCR_RVCT1>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT1>
              <OCR_RVCT2>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT2>
              <OCR_RVCT3>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT3>
              <OCR_RVCT4>
                <Type>1</Type>
                <StartAddress>0x8000000</StartAddress>
                <Size>0x20000</Size>
              </OCR_RVCT4>
              <OCR_RVCT5>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT5>
              <OCR_RVCT6>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT6>
              <OCR_RVCT7>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT7>
              <OCR_RVCT8>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT8>
              <OCR_RVCT9>
                <Type>0</Type>
                <StartAddress>0x20000000</StartAddress>
                <Size>0x5000</Size>
              </OCR_RVCT9>
              <OCR_RVCT10>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT10>
            </OnChipMemories>
            <RvctStartVector></RvctStartVector>
          </ArmAdsMisc>
          <Cads>
            <interw>1</interw>
            <Optim>1</Optim>
            <oTime>0</oTime>
            <SplitLS>0</SplitLS>
            <OneElfS>1</OneElfS>
            <Strict>0</Strict>
            <EnumInt>0</EnumInt>
            <PlainCh>0</PlainCh>
            <Ropi>0</Ropi>
            <Rwpi>0</Rwpi>
            <wLevel>2</wLevel>
            <uThumb>0</uThumb>
            <uSurpInc>0</uSurpInc>
            <uC99>1</uC99>
            <uGnu>0</uGnu>
            <useXO>0</useXO>
            <v6Lang>6</v6Lang>
            <v6LangP>9</v6LangP>
            <vShortEn>1</vShortEn>
            <vShortWch>1</vShortWch>
            <v6Lto>0</v6Lto>
            <v6WtE>1</v6WtE>
            <v6Rtti>0</v6Rtti>
            <VariousControls>
              <MiscControls>-Wno-missing-prototypes -Wno-unreachable-code-return</MiscControls>
              $def_set1 USE_SWD=1, $def_set2
              <Undefine></Undefine>
              <IncludePath>..</IncludePath>
            </VariousControls>
          </Cads>
          <Aads>
            <interw>1</interw>
            <Ropi>0</Ropi>
            <Rwpi>0</Rwpi>
            <thumb>0</thumb>
            <SplitLS>0</SplitLS>
            <SwStkChk>0</SwStkChk>
            <NoWarn>0</NoWarn>
            <uSurpInc>0</uSurpInc>
            <useXO>0</useXO>
            <ClangAsOpt>4</ClangAsOpt>
            <VariousControls>
              <MiscControls></MiscControls>
              <Define></Define>
              <Undefine></Undefine>
              <IncludePath></IncludePath>
            </VariousControls>
          </Aads>
          <LDads>
            <umfTarg>1</umfTarg>
            <Ropi>0</Ropi>
            <Rwpi>0</Rwpi>
            <noStLib>0</noStLib>
            <RepFail>1</RepFail>
            <useFile>0</useFile>
            <TextAddressRange></TextAddressRange>
            <DataAddressRange></DataAddressRange>
            <pXoBase></pXoBase>
            <ScatterFile></ScatterFile>
            <IncludeLibs></IncludeLibs>
            <IncludeLibsPath></IncludeLibsPath>
            <Misc></Misc>
            <LinkerInputFile></LinkerInputFile>
            <DisabledWarnings></DisabledWarnings>
          </LDads>
        </TargetArmAds>
      </TargetOption>
      <Groups>
        <Group>
          <GroupName>startup</GroupName>
          <Files>
            <File>
              <FileName>startup_stm32f103xb.s</FileName>
              <FileType>2</FileType>
              <FilePath>startup_stm32f103xb.s</FilePath>
            </File>
            <File>
              <FileName>system_stm32f1xx.c</FileName>
              <FileType>1</FileType>
              <FilePath>../system_stm32f1xx.c</FilePath>
            </File>
          </Files>
        </Group>
        <Group>
          <GroupName>app</GroupName>
          <Files>
            <File>
              <FileName>main.c</FileName>
              <FileType>1</FileType>
              <FilePath>../main.c</FilePath>
            </File>
          </Files>
        </Group>
      </Groups>
    </Target>
    <Target>
      <TargetName>Release</TargetName>
      <ToolsetNumber>0x4</ToolsetNumber>
      <ToolsetName>ARM-ADS</ToolsetName>
      <pCCUsed>6160000::V6.16::ARMCLANG</pCCUsed>
      <uAC6>1</uAC6>
      <TargetOption>
        <TargetCommonOption>
          <Device>STM32F103CB</Device>
          <Vendor>STMicroelectronics</Vendor>
          <PackID>Keil.STM32F1xx_DFP.2.3.0</PackID>
          <PackURL>http://www.keil.com/pack/</PackURL>
          <Cpu>IRAM(0x20000000,0x00005000) IROM(0x08000000,0x00020000) CPUTYPE("Cortex-M3") CLOCK(8000000) ELITTLE</Cpu>
          <FlashUtilSpec></FlashUtilSpec>
          <StartupFile></StartupFile>
          <FlashDriverDll>UL2CM3(-S0 -C0 -P0 -FD20000000 -FC1000 -FN1 -FF0STM32F10x_128 -FS08000000 -FL020000 -FP0(195Device:STM32F103CB\STM32F10x_128.FLM))</FlashDriverDll>
          <DeviceId>0</DeviceId>
          <RegisterFile>195Device:STM32F103CB\Include\stm32f10x.h</RegisterFile>
          <MemoryEnv></MemoryEnv>
          <Cmp></Cmp>
          <Asm></Asm>
          <Linker></Linker>
          <OHString></OHString>
          <InfinionOptionDll></InfinionOptionDll>
          <SLE66CMisc></SLE66CMisc>
          <SLE66AMisc></SLE66AMisc>
          <SLE66LinkerMisc></SLE66LinkerMisc>
          <SFDFile>195Device:STM32F103CB\STM32F103xx.svd</SFDFile>
          <bCustSvd>0</bCustSvd>
          <UseEnv>0</UseEnv>
          <BinPath></BinPath>
          <IncludePath></IncludePath>
          <LibPath></LibPath>
          <RegisterFilePath></RegisterFilePath>
          <DBRegisterFilePath></DBRegisterFilePath>
          <TargetStatus>
            <Error>0</Error>
            <ExitCodeStop>0</ExitCodeStop>
            <ButtonStop>0</ButtonStop>
            <NotGenerated>0</NotGenerated>
            <InvalidFlash>1</InvalidFlash>
          </TargetStatus>
          <OutputDirectory>.\OUTPUT\</OutputDirectory>
          <OutputName>project</OutputName>
          <CreateExecutable>1</CreateExecutable>
          <CreateLib>0</CreateLib>
          <CreateHexFile>1</CreateHexFile>
          <DebugInformation>0</DebugInformation>
          <BrowseInformation>0</BrowseInformation>
          <ListingPath></ListingPath>
          <HexFormatSelection>1</HexFormatSelection>
          <Merge32K>0</Merge32K>
          <CreateBatchFile>0</CreateBatchFile>
          <BeforeCompile>
            <RunUserProg1>0</RunUserProg1>
            <RunUserProg2>0</RunUserProg2>
            <UserProg1Name></UserProg1Name>
            <UserProg2Name></UserProg2Name>
            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
            <nStopU1X>0</nStopU1X>
            <nStopU2X>0</nStopU2X>
          </BeforeCompile>
          <BeforeMake>
            <RunUserProg1>0</RunUserProg1>
            <RunUserProg2>0</RunUserProg2>
            <UserProg1Name></UserProg1Name>
            <UserProg2Name></UserProg2Name>
            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
            <nStopB1X>0</nStopB1X>
            <nStopB2X>0</nStopB2X>
          </BeforeMake>
          <AfterMake>
            <RunUserProg1>0</RunUserProg1>
            <RunUserProg2>0</RunUserProg2>
            <UserProg1Name></UserProg1Name>
            <UserProg2Name></UserProg2Name>
            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>
            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>
            <nStopA1X>0</nStopA1X>
            <nStopA2X>0</nStopA2X>
          </AfterMake>
          <SelectedForBatchBuild>1</SelectedForBatchBuild>
          <SVCSIdString></SVCSIdString>
        </TargetCommonOption>
        <CommonProperty>
          <UseCPPCompiler>0</UseCPPCompiler>
          <RVCTCodeConst>0</RVCTCodeConst>
          <RVCTZI>0</RVCTZI>
          <RVCTOtherData>0</RVCTOtherData>
          <ModuleSelection>0</ModuleSelection>
          <IncludeInBuild>1</IncludeInBuild>
          <AlwaysBuild>0</AlwaysBuild>
          <GenerateAssemblyFile>0</GenerateAssemblyFile>
          <AssembleAssemblyFile>0</AssembleAssemblyFile>
          <PublicsOnly>0</PublicsOnly>
          <StopOnExitCode>3</StopOnExitCode>
          <CustomArgument></CustomArgument>
          <IncludeLibraryModules></IncludeLibraryModules>
          <ComprImg>0</ComprImg>
        </CommonProperty>
        <DllOption>
          <SimDllName>SARMCM3.DLL</SimDllName>
          <SimDllArguments> -REMAP</SimDllArguments>
          <SimDlgDll>DCM.DLL</SimDlgDll>
          <SimDlgDllArguments>-pCM3</SimDlgDllArguments>
          <TargetDllName>SARMCM3.DLL</TargetDllName>
          <TargetDllArguments></TargetDllArguments>
          <TargetDlgDll>TCM.DLL</TargetDlgDll>
          <TargetDlgDllArguments>-pCM3</TargetDlgDllArguments>
        </DllOption>
        <DebugOption>
          <OPTHX>
            <HexSelection>1</HexSelection>
            <HexRangeLowAddress>0</HexRangeLowAddress>
            <HexRangeHighAddress>0</HexRangeHighAddress>
            <HexOffset>0</HexOffset>
            <Oh166RecLen>16</Oh166RecLen>
          </OPTHX>
        </DebugOption>
        <Utilities>
          <Flash1>
            <UseTargetDll>1</UseTargetDll>
            <UseExternalTool>0</UseExternalTool>
            <RunIndependent>0</RunIndependent>
            <UpdateFlashBeforeDebugging>1</UpdateFlashBeforeDebugging>
            <Capability>1</Capability>
            <DriverSelection>4096</DriverSelection>
          </Flash1>
          <bUseTDR>1</bUseTDR>
          <Flash2>BIN\UL2CM3.DLL</Flash2>
          <Flash3>"" ()</Flash3>
          <Flash4></Flash4>
          <pFcarmOut></pFcarmOut>
          <pFcarmGrp></pFcarmGrp>
          <pFcArmRoot></pFcArmRoot>
          <FcArmLst>0</FcArmLst>
        </Utilities>
        <TargetArmAds>
          <ArmAdsMisc>
            <GenerateListings>0</GenerateListings>
            <asHll>1</asHll>
            <asAsm>1</asAsm>
            <asMacX>1</asMacX>
            <asSyms>1</asSyms>
            <asFals>1</asFals>
            <asDbgD>1</asDbgD>
            <asForm>1</asForm>
            <ldLst>0</ldLst>
            <ldmm>1</ldmm>
            <ldXref>1</ldXref>
            <BigEnd>0</BigEnd>
            <AdsALst>0</AdsALst>
            <AdsACrf>1</AdsACrf>
            <AdsANop>0</AdsANop>
            <AdsANot>0</AdsANot>
            <AdsLLst>0</AdsLLst>
            <AdsLmap>1</AdsLmap>
            <AdsLcgr>1</AdsLcgr>
            <AdsLsym>1</AdsLsym>
            <AdsLszi>1</AdsLszi>
            <AdsLtoi>1</AdsLtoi>
            <AdsLsun>1</AdsLsun>
            <AdsLven>1</AdsLven>
            <AdsLsxf>1</AdsLsxf>
            <RvctClst>0</RvctClst>
            <GenPPlst>0</GenPPlst>
            <AdsCpuType>"Cortex-M3"</AdsCpuType>
            <RvctDeviceName></RvctDeviceName>
            <mOS>0</mOS>
            <uocRom>0</uocRom>
            <uocRam>0</uocRam>
            <hadIROM>1</hadIROM>
            <hadIRAM>1</hadIRAM>
            <hadXRAM>0</hadXRAM>
            <uocXRam>0</uocXRam>
            <RvdsVP>0</RvdsVP>
            <RvdsMve>0</RvdsMve>
            <RvdsCdeCp>0</RvdsCdeCp>
            <hadIRAM2>0</hadIRAM2>
            <hadIROM2>0</hadIROM2>
            <StupSel>8</StupSel>
            <useUlib>1</useUlib>
            <EndSel>0</EndSel>
            <uLtcg>0</uLtcg>
            <nSecure>0</nSecure>
            <RoSelD>3</RoSelD>
            <RwSelD>3</RwSelD>
            <CodeSel>0</CodeSel>
            <OptFeed>0</OptFeed>
            <NoZi1>0</NoZi1>
            <NoZi2>0</NoZi2>
            <NoZi3>0</NoZi3>
            <NoZi4>0</NoZi4>
            <NoZi5>0</NoZi5>
            <Ro1Chk>0</Ro1Chk>
            <Ro2Chk>0</Ro2Chk>
            <Ro3Chk>0</Ro3Chk>
            <Ir1Chk>1</Ir1Chk>
            <Ir2Chk>0</Ir2Chk>
            <Ra1Chk>0</Ra1Chk>
            <Ra2Chk>0</Ra2Chk>
            <Ra3Chk>0</Ra3Chk>
            <Im1Chk>1</Im1Chk>
            <Im2Chk>0</Im2Chk>
            <OnChipMemories>
              <Ocm1>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm1>
              <Ocm2>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm2>
              <Ocm3>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm3>
              <Ocm4>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm4>
              <Ocm5>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm5>
              <Ocm6>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </Ocm6>
              <IRAM>
                <Type>0</Type>
                <StartAddress>0x20000000</StartAddress>
                <Size>0x5000</Size>
              </IRAM>
              <IROM>
                <Type>1</Type>
                <StartAddress>0x8000000</StartAddress>
                <Size>0x20000</Size>
              </IROM>
              <XRAM>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </XRAM>
              <OCR_RVCT1>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT1>
              <OCR_RVCT2>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT2>
              <OCR_RVCT3>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT3>
              <OCR_RVCT4>
                <Type>1</Type>
                <StartAddress>0x8000000</StartAddress>
                <Size>0x20000</Size>
              </OCR_RVCT4>
              <OCR_RVCT5>
                <Type>1</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT5>
              <OCR_RVCT6>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT6>
              <OCR_RVCT7>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT7>
              <OCR_RVCT8>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT8>
              <OCR_RVCT9>
                <Type>0</Type>
                <StartAddress>0x20000000</StartAddress>
                <Size>0x5000</Size>
              </OCR_RVCT9>
              <OCR_RVCT10>
                <Type>0</Type>
                <StartAddress>0x0</StartAddress>
                <Size>0x0</Size>
              </OCR_RVCT10>
            </OnChipMemories>
            <RvctStartVector></RvctStartVector>
          </ArmAdsMisc>
          <Cads>
            <interw>1</interw>
            <Optim>6</Optim>
            <oTime>0</oTime>
            <SplitLS>0</SplitLS>
            <OneElfS>1</OneElfS>
            <Strict>0</Strict>
            <EnumInt>0</EnumInt>
            <PlainCh>0</PlainCh>
            <Ropi>0</Ropi>
            <Rwpi>0</Rwpi>
            <wLevel>2</wLevel>
            <uThumb>0</uThumb>
            <uSurpInc>0</uSurpInc>
            <uC99>1</uC99>
            <uGnu>0</uGnu>
            <useXO>0</useXO>
            <v6Lang>6</v6Lang>
            <v6LangP>9</v6LangP>
            <vShortEn>1</vShortEn>
            <vShortWch>1</vShortWch>
            <v6Lto>1</v6Lto>
            <v6WtE>1</v6WtE>
            <v6Rtti>0</v6Rtti>
            <VariousControls>
              <MiscControls>-Wno-missing-prototypes -Wno-unreachable-code-return</MiscControls>
              $def_set1 NDEBUG, USE_SWD=0, $def_set2
              <Undefine></Undefine>
              <IncludePath>..</IncludePath>
            </VariousControls>
          </Cads>
          <Aads>
            <interw>1</interw>
            <Ropi>0</Ropi>
            <Rwpi>0</Rwpi>
            <thumb>0</thumb>
            <SplitLS>0</SplitLS>
            <SwStkChk>0</SwStkChk>
            <NoWarn>0</NoWarn>
            <uSurpInc>0</uSurpInc>
            <useXO>0</useXO>
            <ClangAsOpt>4</ClangAsOpt>
            <VariousControls>
              <MiscControls></MiscControls>
              <Define></Define>
              <Undefine></Undefine>
              <IncludePath></IncludePath>
            </VariousControls>
          </Aads>
          <LDads>
            <umfTarg>1</umfTarg>
            <Ropi>0</Ropi>
            <Rwpi>0</Rwpi>
            <noStLib>0</noStLib>
            <RepFail>1</RepFail>
            <useFile>0</useFile>
            <TextAddressRange></TextAddressRange>
            <DataAddressRange></DataAddressRange>
            <pXoBase></pXoBase>
            <ScatterFile></ScatterFile>
            <IncludeLibs></IncludeLibs>
            <IncludeLibsPath></IncludeLibsPath>
            <Misc></Misc>
            <LinkerInputFile></LinkerInputFile>
            <DisabledWarnings></DisabledWarnings>
          </LDads>
        </TargetArmAds>
      </TargetOption>
      <Groups>
        <Group>
          <GroupName>startup</GroupName>
          <Files>
            <File>
              <FileName>startup_stm32f103xb.s</FileName>
              <FileType>2</FileType>
              <FilePath>startup_stm32f103xb.s</FilePath>
            </File>
            <File>
              <FileName>system_stm32f1xx.c</FileName>
              <FileType>1</FileType>
              <FilePath>../system_stm32f1xx.c</FilePath>
            </File>
          </Files>
        </Group>
        <Group>
          <GroupName>app</GroupName>
          <Files>
            <File>
              <FileName>main.c</FileName>
              <FileType>1</FileType>
              <FilePath>../main.c</FilePath>
            </File>
          </Files>
        </Group>
      </Groups>
    </Target>
  </Targets>
  <RTE>
    <apis/>
    <components/>
    <files/>
  </RTE>
</Project>
MDK_CONFIG
  cd ..
fi


#
# generate main.h
#

cat <<MAIN_H >main.h
#ifndef __MAIN_H
#define __MAIN_H

#include "stm32f1xx.h"

#ifdef __cplusplus
 extern C {
#endif


/* *********************************************************************************** */
/* ******** Uncomment lines below if these features are required ********************* */
/* *********************************************************************************** */
#if 0                                      /*                                          */
  #define USE_HSE                       1  /* Use crystall oscillator as clock source  */
  #define USE_PLL                       1  /* Use PLL as system clock source           */
  #define USE_LSE                       1  /* Use LSE as RTC clock source              */
  #define USE_ADC                       1  /* Configure ADC1 peripheral                */
  #define USE_USART                     1  /* Configure USART1 for send and receive    */
  #define USE_I2C                       1  /* Configure I2C1 100kHz                    */
  #define USE_SPI                       1  /* Configure SPI1                           */
  #define USE_BTN                       1  /* Handle buttons connected to PB1 and PB2  */
  #define USE_RTC                       1  /* Configure and run RTC                    */
  #define USE_TIM2                      1  /* Configure and run TIM2                   */
  #define USE_CRC                       1  /* Add CRC computation code                 */
  #define USE_RNG                       1  /* Add random numbers generation code       */
  #define USE_IWDG                      1  /* Enable independent hardware watchdog     */
  #define USE_WWDG                      1  /* Enable windows hardware watchdog         */
  #define USE_EXTI                      1  /* Use external interrupt                   */
  #define USE_FLASH                     1  /* Add feature to write data to flash       */
  #define USE_SWD                       1  /* Use SWD pins for debugging               */
  #define OVRCLK                        1  /* Overclock microcontroller (112 mhz)      */
#endif                                     /*                                          */
/* *********************************************************************************** */
/* **********  or use it as command line parameters for make utility  **************** */
/* *********************************************************************************** */

#define PORT_CFG(PORT, CFG)             *(__IO uint64_t*) GPIO##PORT##_BASE = (CFG)

#define PORT_CONFIG(PORT, CFG, STATE)   if (!0) {                                      \\
                                          if (CFG) { PORT_CFG(PORT, CFG); }            \\
                                          if (STATE) { GPIO##PORT->BSRR = (STATE); }   \\
                                        } else (void) 0

#define PIN_CFG(PIN, MODE)              ((MODE) << ((PIN) * 4))
                                                                                       /*
    In input mode (MODE[1:0] = 00):

  00: Analog mode
  01: Floating input (reset state)
  10: Input with pull-up / pull-down
  11: Reserved
                                                                                       */
#define I_ANALOG                        (0ULL << 2)
#define I_FLOAT                         (1ULL << 2)
#define I_PULL                          (2ULL << 2)
                                                                                       /*
    In output mode (MODE[1:0] > 00):

  00: General purpose output push-pull
  01: General purpose output Open-drain
  10: Alternate function output Push-pull
  11: Alternate function output Open-drain
                                                                                       */
#define O_PP                            (0ULL << 2)
#define O_OD                            (1ULL << 2)
#define O_AF                            (2ULL << 2)
                                                                                       /*
  MODEy[1:0]: Port x mode bits (y = 0 .. 7)
  These bits are written by software to configure the corresponding I/O port.
  Refer to Table 20: Port bit configuration table.

  00: Input mode (reset state)
  01: Output mode, max speed 10 MHz.
  10: Output mode, max speed 2 MHz.
  11: Output mode, max speed 50 MHz.
                                                                                       */
#define O_10MHZ                         1ULL
#define O_2MHZ                          2ULL
#define O_50MHZ                         3ULL

#define DOWN                            GPIO_BSRR_BR
#define UP                              GPIO_BSRR_BS

#define CAT(A, B)                       A ## B
#define SW_PIN(PORT, PIN, STATE)        GPIO ## PORT->BSRR = CAT(STATE, PIN)
#define PULL(PIN, STATE)                CAT(STATE, PIN)
#define HIGH(PIN)                       GPIO_BSRR_BS ## PIN
#define LOW(PIN)                        GPIO_BSRR_BR ## PIN

#define PIN_HIGH(PIN)                   GPIO_BSRR_BS ## PIN
#define PIN_LOW(PIN)                    GPIO_BSRR_BR ## PIN
#define PULL_UP(PIN)                    GPIO_BSRR_BS ## PIN
#define PULL_DOWN(PIN)                  GPIO_BSRR_BR ## PIN

#define ATOMIC_OUT(PORT, DATA)          PORT->BSRR = 0x00FF0000 | (DATA)
#define READ_PIN(PORT, PIN)             (GPIO ## PORT->IDR & GPIO_IDR_IDR ## PIN)

#define GET_BIT(AREA, ADDR, BIT)        *(volatile uint32_t*)(AREA ## _BB_BASE + 32 * ((uint32_t)&ADDR - AREA ## _BASE) + 4 * __builtin_ctz(BIT))

#define READ_MEM_BIT(REG, BIT)          GET_BIT(SRAM, REG, BIT)
#define WRITE_MEM_BIT(REG, BIT, VAL)    READ_MEM_BIT(REG, BIT) = VAL
#define SET_MEM_BIT(REG, BIT)           WRITE_MEM_BIT(REG, BIT, 1)
#define CLEAR_MEM_BIT(REG, BIT)         WRITE_MEM_BIT(REG, BIT, 0)

#define READ_REG_BIT(REG, BIT)          GET_BIT(PERIPH, REG, BIT)
#define WRITE_REG_BIT(REG, BIT, VAL)    READ_REG_BIT(REG, BIT) = VAL
#define SET_REG_BIT(REG, BIT)           WRITE_REG_BIT(REG, BIT, 1)
#define CLEAR_REG_BIT(REG, BIT)         WRITE_REG_BIT(REG, BIT, 0)

#define GET_TICK()                      (SysTick->CTRL >> SysTick_CTRL_COUNTFLAG_Pos)
#define DELAY_MS(MS)                    do {(void)SysTick->CTRL; for(unsigned _ = MS; _; _ -= GET_TICK()) {}}while(0)


__STATIC_FORCEINLINE void delay_ms(unsigned ms) {(void)SysTick->CTRL; while(ms -= GET_TICK());}


#define WAIT_FOR_FLAG(REG, FLAG, TIMEOUT) do {                                  \\
          unsigned timeout = SysTick->CTRL >> (SysTick_CTRL_COUNTFLAG_Pos + 1); \\
          while(((REG) & (FLAG)) != (FLAG)) {                                   \\
            timeout += GET_TICK();                                              \\
            if (timeout > (TIMEOUT)) {                                          \\
              return ERROR;                                                     \\
            }                                                                   \\
          }                                                                     \\
        } while(0)

#if defined USE_HSE && USE_HSE != 0
  #define HSE_EN                        1
#else
  #define HSE_EN                        0
#endif

#if defined USE_PLL && USE_PLL != 0
  #define PLL_EN                        1
#else
  #define PLL_EN                        0
#endif

#if defined USE_LSE && USE_LSE != 0
  #define LSE_EN                        1
#else
  #define LSE_EN                        0
#endif

#if defined USE_BTN && USE_BTN != 0
  #define BTN_EN                        1
#else
  #define BTN_EN                        0
#endif

#if defined USE_TIM2 && USE_TIM2 != 0
  #define TIM2_EN                       1
#else
  #define TIM2_EN                       0
#endif

#if defined USE_EXTI && USE_EXTI != 0
  #define EXTI_EN                       1
#else
  #define EXTI_EN                       0
#endif

#if defined USE_IWDG && USE_IWDG != 0
  #define IWDG_EN                       1
#else
  #define IWDG_EN                       0
#endif

#if defined USE_WWDG && USE_WWDG != 0
  #define WWDG_EN                       1
  #define WWDG_COUNTER                  0x7F
  #define WWDG_WINDOW                   0x60
#else
  #define WWDG_EN                       0
#endif

#if defined USE_SWD && USE_SWD != 0
  #define SWD_EN                        1
#else
  #define SWD_EN                        0
#endif

#if defined USE_RTC && USE_RTC != 0
  #define RTC_EN                        1

  typedef struct{
    uint16_t year;
    uint8_t  month;
    uint8_t  day;
    uint8_t  wday;
    uint8_t  hour;
    uint8_t  minute;
    uint8_t  second;
  } time_struct_t;

  /* http://we.easyelectronics.ru/Soft/funkcii-kalendarya-i-vremeni-na-odnom-registre.html */
  #if 0
    #define JD0 2451911
  #else
    /* #define JD0 2440587 */
    #define JD0 2440588
  #endif

  __STATIC_INLINE unsigned time_to_unixtime(time_struct_t * t) {

    uint8_t a = (14 - t->month) / 12;
    uint16_t y = t->year + 4800 - a;
    uint8_t m = t->month + (12 * a) - 3;
    uint32_t counter = t->day;

    counter += (153 * m + 2) / 5;
    counter += 365 * y;
    counter += y / 4;
    counter -= y / 100;
    counter += y / 400;
    counter -= 32045;
    counter -= JD0;
    counter *= 86400;
    counter += (t->hour * 3600);
    counter += (t->minute * 60);
    counter += (t->second);

    return counter;
  }

  __STATIC_INLINE void unixtime_to_time(uint32_t utime, time_struct_t * t) {

    uint32_t ace = (utime / 86400) + 32044 + JD0;
    uint32_t b = (4 * ace + 3) / 146097;
    ace = ace - ((146097 * b) / 4);
    uint32_t d = (4 * ace + 3) / 1461;
    ace = ace - ((1461 * d) / 4);
    uint32_t m = (5 * ace + 2) / 153;
    t->day = (uint8_t)(ace - ((153 * m + 2) / 5) + 1);
    t->month = (uint8_t) (m + 3 - (12 * (m / 10)));
    t->year = (uint16_t) (100 * b + d - 4800 + (m / 10));
    t->hour = (utime / 3600) % 24;
    t->minute = (utime / 60) % 60;
    t->second = (utime % 60);
  }

  __STATIC_INLINE unsigned rtc_read_counter(void) {
    unsigned a = RTC->CNTH, b = RTC->CNTL, c = RTC->CNTH;

    if (a != c) {
      a = c;
      b = RTC->CNTL;
    }
    a = (a << 16U) | b;
    return a;
  }

  void rtc_set_alarm(uint32_t alarm_time) {

    #if 0
      while((RTC->CRL & RTC_CRL_SECF) != RTC_CRL_SECF)  {
          /* JUST WAIT */
      }
      RTC->CRL &= (uint16_t)~(RTC_CRL_ALRF | RTC_CRL_SECF);

      uint32_t timeout = 1000;
      while ((RTC->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET) {
        /* just wait for RTOFF  */
        timeout -= GET_TICK();
        if (timeout == 0) return;
      }

      uint32_t apb1enr_flags = 0;
      if ((RCC->APB1ENR & RCC_APB1ENR_BKPEN) != RCC_APB1ENR_BKPEN) {
        RCC->APB1ENR |= RCC_APB1ENR_BKPEN;
        apb1enr_flags |= RCC_APB1ENR_BKPEN;
      }

      if ((RCC->APB1ENR & RCC_APB1ENR_PWREN) != RCC_APB1ENR_PWREN) {
        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
        apb1enr_flags |= RCC_APB1ENR_PWREN;
      }
    #endif


    RCC->APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);

    // while((RTC->CRL & RTC_CRL_RSF) != RTC_CRL_RSF)  {
    //     /* JUST WAIT */
    // }

    #if 0
      while((RTC->CRL & RTC_CRL_RTOFF) != RTC_CRL_RTOFF) {
          /* JUST WAIT */
      }
    #endif

    PWR->CR |= PWR_CR_DBP;                                  /* Disable Backup Domain Protection     */

    uint32_t timeout = 1000;
    while ((RTC->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET) {
      /* just wait for RTOFF  */
      timeout -= GET_TICK();
      if (timeout == 0) return;
    }

    RTC->CRL |= RTC_CRL_CNF;

    alarm_time--;

    RTC->ALRH = alarm_time >> 16;
    RTC->ALRL = alarm_time;

    RTC->CRL &= (uint16_t)~(RTC_CRL_ALRF | RTC_CRL_SECF);
    RTC->CRH |= RTC_CRH_ALRIE;
    RTC->CRL = ~RTC_CRL_CNF;

    RTC->CRL &= (uint16_t)~RTC_CRL_RSF;
    while((RTC->CRL & RTC_CRL_RSF) != RTC_CRL_RSF) {}

    // RCC->APB1ENR &= ~apb1enr_flags;

    // while((RTC->CRL & RTC_CRL_RSF) != RTC_CRL_RSF)  {
    //     /* JUST WAIT */
    // }


    timeout = 1000;
    while ((RTC->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET) {
      /* just wait for RTOFF  */
      timeout -= GET_TICK();
      if (timeout == 0) return;
    }

    /* Note: If the HSE divided by 128 is used as the RTC clock, this bit must remain set to 1.     */
    #if LSE_EN || !HSE_EN
      PWR->CR &= ~PWR_CR_DBP;                                   /* Restore Backup Domain Protection   */
    #endif

    RCC->APB1ENR &= ~(RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
  }

#else
  #define RTC_EN                        0
#endif

#if defined USE_ADC && USE_ADC != 0

  #define ADC_EN                        1

  #define ADC_CHANNEL_0                 0x00000000U
  #define ADC_CHANNEL_1                 (                                                                        ADC_CR1_AWDCH_0)
  #define ADC_CHANNEL_2                 (                                                      ADC_CR1_AWDCH_1                  )
  #define ADC_CHANNEL_3                 (                                                      ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0)
  #define ADC_CHANNEL_4                 (                                    ADC_CR1_AWDCH_2                                    )
  #define ADC_CHANNEL_5                 (                                    ADC_CR1_AWDCH_2                   | ADC_CR1_AWDCH_0)
  #define ADC_CHANNEL_6                 (                                    ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1                  )
  #define ADC_CHANNEL_7                 (                                    ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0)
  #define ADC_CHANNEL_8                 (                  ADC_CR1_AWDCH_3                                                      )
  #define ADC_CHANNEL_9                 (                  ADC_CR1_AWDCH_3                                     | ADC_CR1_AWDCH_0)
  #define ADC_CHANNEL_10                (                  ADC_CR1_AWDCH_3                   | ADC_CR1_AWDCH_1                  )
  #define ADC_CHANNEL_11                (                  ADC_CR1_AWDCH_3                   | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0)
  #define ADC_CHANNEL_12                (                  ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2                                    )
  #define ADC_CHANNEL_13                (                  ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2                   | ADC_CR1_AWDCH_0)
  #define ADC_CHANNEL_14                (                  ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1                  )
  #define ADC_CHANNEL_15                (                  ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0)
  #define ADC_CHANNEL_16                (ADC_CR1_AWDCH_4                                                                        )
  #define ADC_CHANNEL_17                (ADC_CR1_AWDCH_4                                                       | ADC_CR1_AWDCH_0)

  #define ADC_SAMPLING_TIME_1_5         (0x00000000U                                           ) /* Sampling time   1.5 ADC clock cycle  */
  #define ADC_SAMPLING_TIME_7_5         (                                      ADC_SMPR2_SMP0_0) /* Sampling time   7.5 ADC clock cycles */
  #define ADC_SAMPLING_TIME_13_5        (                   ADC_SMPR2_SMP0_1                   ) /* Sampling time  13.5 ADC clock cycles */
  #define ADC_SAMPLING_TIME_28_5        (                   ADC_SMPR2_SMP0_1 | ADC_SMPR2_SMP0_0) /* Sampling time  28.5 ADC clock cycles */
  #define ADC_SAMPLING_TIME_41_5        (ADC_SMPR2_SMP0_2                                      ) /* Sampling time  41.5 ADC clock cycles */
  #define ADC_SAMPLING_TIME_55_5        (ADC_SMPR2_SMP0_2 |                    ADC_SMPR2_SMP0_0) /* Sampling time  55.5 ADC clock cycles */
  #define ADC_SAMPLING_TIME_71_5        (ADC_SMPR2_SMP0_2 | ADC_SMPR2_SMP0_1                   ) /* Sampling time  71.5 ADC clock cycles */
  #define ADC_SAMPLING_TIME_239_5       (ADC_SMPR2_SMP0_2 | ADC_SMPR2_SMP0_1 | ADC_SMPR2_SMP0_0) /* Sampling time 239.5 ADC clock cycles */

  #define ADC_SQR1(SEQ_NUM, CH_NUM)     ((ADC_CHANNEL_ ## CH_NUM << ADC_SQR1_SQ ## SEQ_NUM ##_Pos) & ADC_SQR1_SQ ## SEQ_NUM)
  #define ADC_SQR2(SEQ_NUM, CH_NUM)     ((ADC_CHANNEL_ ## CH_NUM << ADC_SQR2_SQ ## SEQ_NUM ##_Pos) & ADC_SQR2_SQ ## SEQ_NUM)
  #define ADC_SQR3(SEQ_NUM, CH_NUM)     ((ADC_CHANNEL_ ## CH_NUM << ADC_SQR3_SQ ## SEQ_NUM ##_Pos) & ADC_SQR3_SQ ## SEQ_NUM)
  #define ADC_SQR1_LEN(LEN)             (((uint32_t)((LEN) - 1) << ADC_SQR1_L_Pos) & ADC_SQR1_L)

  #define ADC_SMPR1(SEQ_NUM, CYCLES)    ((ADC_SAMPLING_TIME_ ## CYCLES ## _5 << ADC_SMPR1_SMP ## SEQ_NUM ## _Pos) & ADC_SMPR1_SMP ## SEQ_NUM)
  #define ADC_SMPR2(SEQ_NUM, CYCLES)    ((ADC_SAMPLING_TIME_ ## CYCLES ## _5 << ADC_SMPR2_SMP ## SEQ_NUM ## _Pos) & ADC_SMPR2_SMP ## SEQ_NUM)


  __STATIC_INLINE unsigned adc_get_bit(void) {
    while (!READ_REG_BIT(ADC1->SR, ADC_SR_EOC)) {
    }
    return READ_REG_BIT(ADC1->DR, 1);
  }


  __STATIC_INLINE unsigned adc_get_random_bit(void) {
    unsigned a;
    do {
      a = adc_get_bit();
    } while (a == adc_get_bit());
    return a;
  }

  __STATIC_INLINE unsigned adc_get_average(unsigned count) {
    unsigned average = 0;
    for(unsigned i = 0; i < count; i++) {

      while (!READ_REG_BIT(ADC1->SR, ADC_SR_EOC)) { }
      average += ADC1->DR;

      #if WWDG_EN
        if ((WWDG->CR & WWDG_CR_T) < WWDG_WINDOW) {
          /* RESET WWDG */
          WWDG->CR = WWDG_COUNTER;
        }
      #endif
    }
    return average / count;
  }


  __STATIC_INLINE void get_adc_internals(short *t, unsigned short *v) {

    #if PLL_EN
      enum { ADC_SAMPLE_COUNT = 4096 };
    #else
      enum { ADC_SAMPLE_COUNT = 128 };
    #endif

    unsigned vcc_data = 0, temp_data = 0;

    #if 0
      for(unsigned i = 0; i < ADC_SAMPLE_COUNT; i++) {

        while (!READ_REG_BIT(ADC1->SR, ADC_SR_EOC)) { }
        temp_data += ADC1->DR;

        #if WWDG_EN
          if ((WWDG->CR & WWDG_CR_T) < WWDG_WINDOW) {
            /* RESET WWDG */
            WWDG->CR = WWDG_COUNTER;
          }
        #endif
      }
      CLEAR_REG_BIT(ADC1->CR2, ADC_CR2_ADON);
      temp_data /= ADC_SAMPLE_COUNT;
      while (READ_REG_BIT(ADC1->CR2, ADC_CR2_ADON)) { }
    #else
      temp_data = adc_get_average(ADC_SAMPLE_COUNT);
      CLEAR_REG_BIT(ADC1->CR2, ADC_CR2_ADON);
      while (READ_REG_BIT(ADC1->CR2, ADC_CR2_ADON)) { }
    #endif

    ADC1->SQR3 = ADC_SQR3(1, 17);
    SET_REG_BIT(ADC1->CR2, ADC_CR2_ADON);
    SET_REG_BIT(ADC1->CR2, ADC_CR2_ADON);

    #if 0
      for(unsigned i = 0; i < ADC_SAMPLE_COUNT; i++) {

        while (!READ_REG_BIT(ADC1->SR, ADC_SR_EOC)) { }
        vcc_data += ADC1->DR;

        #if WWDG_EN
          if ((WWDG->CR & WWDG_CR_T) < WWDG_WINDOW) {
            /* RESET WWDG */
            WWDG->CR = WWDG_COUNTER;
          }
        #endif
      }
      CLEAR_REG_BIT(ADC1->CR2, ADC_CR2_ADON);
      vcc_data /= ADC_SAMPLE_COUNT;
      while (READ_REG_BIT(ADC1->CR2, ADC_CR2_ADON)) { }
    #else
      vcc_data = adc_get_average(ADC_SAMPLE_COUNT);
      CLEAR_REG_BIT(ADC1->CR2, ADC_CR2_ADON);
      while (READ_REG_BIT(ADC1->CR2, ADC_CR2_ADON)) { }
    #endif

    ADC1->SQR3 = ADC_SQR3(1, 16);
    SET_REG_BIT(ADC1->CR2, ADC_CR2_ADON);
    SET_REG_BIT(ADC1->CR2, ADC_CR2_ADON);

    unsigned vcc = 1200UL * 4095UL / vcc_data;
    int temp = temp_data * vcc / 4095L;
    temp = ((1430L - temp) * 10L / 43L) + 25L;
    if (t != NULL) *t = (short) temp;
    if (v != NULL) *v = (unsigned short) vcc;
  }

#else
  #define ADC_EN                        0
#endif

#if defined USE_USART && USE_USART != 0
  #define USART_EN                      1
  #define BAUDRATE 115200
#else
  #define USART_EN                      0
#endif

#if defined USE_I2C && USE_I2C != 0
  #define I2C_EN                        1
  #define I2C_SPEED_STANDARD            100000
  #define I2C_SPEED_FAST                400000

  #if !0
    #define I2C_CCR                     (((APB1_CLK / I2C_SPEED_STANDARD / 2) & I2C_CCR_CCR) < 4U) ? 4U : APB1_CLK / I2C_SPEED_STANDARD / 2
    #define I2C_TRISE                   APB1_CLK / 1000000 + 1
  #else
    #define I2C_CCR                     (((APB1_CLK / I2C_SPEED_FAST / 3) & I2C_CCR_CCR) == 0U) ? 1U : APB1_CLK / I2C_SPEED_FAST / 3
    #define I2C_TRISE                   3 * APB1_CLK / 10000000 + 1
  #endif

#else
  #define I2C_EN                        0
#endif

#if defined USE_SPI && USE_SPI != 0

  #define SPI_EN                        1

  __STATIC_INLINE char spi_xfer(char d) {
    while(!READ_REG_BIT(SPI1->SR, SPI_SR_TXE)) {
      /* wait until spi transfer completes */
    }
    *((__IO char *)&SPI1->DR) = d;
    while(!READ_REG_BIT(SPI1->SR, SPI_SR_RXNE)) {
      /* wait until spi transfer completes */
    }
    return *(__IO char *)&SPI1->DR;
  }

  #define CS_PORT                       GPIOA
  #define CS_PIN                        4
  #define CS(STATE)                     CS_PORT->BSRR = (1UL << ((!STATE) * 16 + CS_PIN))
  #define CS_LOW()                      CS(0)
  #define CS_HIGH()                     CS(1)

#else
  #define SPI_EN                        0
#endif

#if defined USE_CRC && USE_CRC != 0
  #define CRC_EN                        1
  __STATIC_INLINE unsigned crc32_zlib(const unsigned *data, unsigned short cnt) {

    unsigned i;

    CRC->CR = CRC_CR_RESET;

    for (i = 0; i < (cnt / 4); i++) CRC->DR = __RBIT(data[i]);

    unsigned result = __RBIT(CRC->DR);
    cnt = (cnt % 4) * 8;
    if (cnt) {
      CRC->DR = CRC->DR;
      CRC->DR = __RBIT((data[i] & (0xFFFFFFFF >> (32 - cnt))) ^ result) >> (32 - cnt);
      result = (result >> cnt) ^ __RBIT(CRC->DR);
    }
    return ~result;
  }
#else
  #define CRC_EN                        0
#endif

#if defined USE_RNG && USE_RNG != 0

  #define RNG_EN                        1

  __STATIC_INLINE unsigned prnd(void) {

    unsigned *addr = (unsigned *) APB1PERIPH_BASE;
    for (unsigned i = 0; i < 0x2000; i++) {
      CRC->DR = *addr++;
    }

    addr = (unsigned *) APB2PERIPH_BASE;
    for (unsigned i = 0; i < 0x1000; i++) {
      CRC->DR = *addr++;
    }

    addr = (unsigned *) AHBPERIPH_BASE;
    for (unsigned i = 0; i < 0x100; i++) {
      CRC->DR = *addr++;
    }

    return CRC->DR;
  }
#else
  #define RNG_EN                        0
#endif

#if defined USE_FLASH && USE_FLASH != 0

  #define FLASH_EN                      1

  #define FLASH_DATA_ADDR               0x0801FC00
  #define FLASH_PAGE_SIZE               0x00000400

  #define FLASH_ERROR                   0x01
  #define FLASH_ERROR_ERASE             0x02
  #define FLASH_ERROR_WRITE             0x04
  #define FLASH_ERROR_WRITE_PROT        0x08
  #define FLASH_ERROR_UNKNOWN           0x10

  #define FLASH_ERR                     (FLASH_SR_PGERR | FLASH_SR_WRPRTERR)

  __STATIC_INLINE unsigned write2flash(uint16_t src[], uint16_t len) {
    unsigned status = 0;

    /* Note: execution time of the function is about 81 ms @ 72 MHz                                 */
                                                              /*
    1) UNLOCK THE FLASH
    ========================================================= */

    while (READ_REG_BIT(FLASH->SR, FLASH_SR_BSY)) {/* */}     /* Wait till no operation is on going */

    if (READ_REG_BIT(FLASH->CR, FLASH_CR_LOCK)) {             /* Check the Flash is locked          */
      FLASH->KEYR = FLASH_KEY1;                               /* Perform unlock sequence            */
      FLASH->KEYR = FLASH_KEY2;
    }
                                                              /*
    2) ERASE THE DATA AREA
    ========================================================= */

    SET_REG_BIT(FLASH->CR, FLASH_CR_PER);                     /* Enable page erasing mode           */
    FLASH->AR = FLASH_DATA_ADDR;                              /* Set page address                   */
    SET_REG_BIT(FLASH->CR, FLASH_CR_STRT);                    /* Start the erasing                  */

    while (!READ_REG_BIT(FLASH->SR, FLASH_SR_EOP)) {/* */}    /* Wait till page be erased           */
    CLEAR_REG_BIT(FLASH->CR, FLASH_CR_PER);                   /* Reset page erasing flag            */
    SET_REG_BIT(FLASH->SR, FLASH_SR_EOP);                     /* clear OPERATION COMPLETE flag      */

    if (READ_REG_BIT(FLASH->SR, FLASH_ERR)) {
      if (READ_REG_BIT(FLASH->SR, FLASH_SR_WRPRTERR)) {       /* Check Write protection error       */
        status = FLASH_ERROR_WRITE_PROT;                      /* Report the error                   */
        SET_REG_BIT(FLASH->SR, FLASH_SR_WRPRTERR);            /* Clear the error flag               */
      } else {
        status = FLASH_ERROR_WRITE;                           /* Report the error                   */
        SET_REG_BIT(FLASH->SR, FLASH_SR_PGERR);               /* Clear the error flag               */
      }
      return status;                                          /* Break flashing                     */
    }
                                                              /*
    3) CHECK THE DATA AREA CLEARED
    ========================================================= */

    for(int *i = (int *)FLASH_DATA_ADDR; i < (int *)(FLASH_DATA_ADDR + FLASH_PAGE_SIZE); i++) {
      if (*i != -1L) {                                        /* If page not clean                  */
        return  FLASH_ERROR_ERASE;                            /* Report the error                   */
      }
    }
                                                              /*
    4) WRITE DATA TO THE FLASH
    ========================================================= */

    __IO uint16_t* p = (__IO uint16_t*) FLASH_DATA_ADDR;

    SET_REG_BIT(FLASH->CR, FLASH_CR_PG);                      /* Enable programming mode            */
    for (unsigned i = 0; i < len / 2; i++) {                  /* Start writing cycle                */

      *p = src[i];                                            /* Write 16 bits data                 */

      while (!READ_REG_BIT(FLASH->SR, FLASH_SR_EOP)) {/* */}  /* Wait till the operation completes  */
      SET_REG_BIT(FLASH->SR, FLASH_SR_EOP);                   /* clear OPERATION COMPLETE flag      */

      if (READ_REG_BIT(FLASH->SR, FLASH_ERR)) {
        if (READ_REG_BIT(FLASH->SR, FLASH_SR_WRPRTERR)) {     /* Check for write protection error   */
          status = FLASH_ERROR_WRITE_PROT;                    /* Report the error                   */
          SET_REG_BIT(FLASH->SR, FLASH_SR_WRPRTERR);          /* Clear the error flag               */
        } else {
          status = FLASH_ERROR_WRITE;                         /* Report the error                   */
          SET_REG_BIT(FLASH->SR, FLASH_SR_PGERR);             /* Clear the error flag               */
        }
        CLEAR_REG_BIT(FLASH->CR, FLASH_CR_PG);                /* Disable programming                */
        return status;                                        /* Break flashing                     */
      }
      p++;                                                    /* Next address to write data to      */
    }

    CLEAR_REG_BIT(FLASH->CR, FLASH_CR_PG);                    /* Disable programming                */
    return !FLASH_ERROR;                                      /* Return success                     */
  }

  #define OB_RDP_LEVEL_0            ((uint8_t)0xA5)
  #define OB_RDP_LEVEL_1            ((uint8_t)0x00)

  __STATIC_INLINE void __attribute__((noreturn)) lock_firmware(uint8_t *ud_0, uint8_t *ud_1) {

    while (READ_REG_BIT(FLASH->SR, FLASH_SR_BSY)) {/* */}     /* Wait till no operation is on going */

    FLASH->KEYR = FLASH_KEY1;                                 /* Perform FLASH unlock sequence      */
    FLASH->KEYR = FLASH_KEY2;

    FLASH->OPTKEYR = FLASH_OPTKEY1;                           /* Perform OPT BYTE unlock sequence   */
    FLASH->OPTKEYR = FLASH_OPTKEY2;

    SET_REG_BIT(FLASH->CR, FLASH_CR_OPTER);                   /* Enable OPT BYTE erasing operation  */
    SET_REG_BIT(FLASH->CR, FLASH_CR_STRT);                    /* Start erasing..                    */

    while (READ_REG_BIT(FLASH->SR, FLASH_SR_BSY)) {/* */}     /* Wait till no operation is on going */

    CLEAR_REG_BIT(FLASH->CR, FLASH_CR_OPTER);                 /* Disable OPT BYTE erase operation   */
    SET_REG_BIT(FLASH->CR, FLASH_CR_OPTPG);                   /* Enable OPT BYTE programming op.    */

    if (ud_0 != NULL) {                                       /* if user byte #0 is passed          */
      OB->Data0 = *ud_0;                                      /* write it to OPT BYTE               */
      while (!READ_REG_BIT(FLASH->SR, FLASH_SR_EOP)) {/* */}  /* wait until write op completes      */
      SET_REG_BIT(FLASH->SR, FLASH_SR_EOP);                   /* clear OPERATION COMPLETE flag      */
    }

    if (ud_1 != NULL) {                                       /* if user byte #0 is passed          */
      OB->Data1 = *ud_1;                                      /* write it to OPT BYTE               */
      while (!READ_REG_BIT(FLASH->SR, FLASH_SR_EOP)) {/* */}  /* wait until write op completes      */
      SET_REG_BIT(FLASH->SR, FLASH_SR_EOP);                   /* clear OPERATION COMPLETE flag      */
    }
                                                                                                    /*
      For medium-density devices, one bit of the user option bytes WRPx is used to
      protect 4 pages of 1 Kbyte in main memory block.
        0: Write protection active
        1: Write protection not active
      In total, four user option bytes are used to protect the 128-Kbyte main Flash
      memory.
      WRP0: Write-protects pages 0 to 31
      WRP1: Write-protects pages 32 to 63
      WRP2: Write-protects pages 64 to 95
      WRP3: Write-protects pages 96 to 127
                                                                                                    */
    OB->WRP0 = (uint16_t)0x00;                                /* write-protect pages 0 to 31        */
    while (!READ_REG_BIT(FLASH->SR, FLASH_SR_EOP)) {/* */}    /* wait until write op completes      */
    SET_REG_BIT(FLASH->SR, FLASH_SR_EOP);                     /* clear OPERATION COMPLETE flag      */

    OB->WRP1 = (uint16_t)0x00;                                /* write-protect pages 32 to 63       */
    while (!READ_REG_BIT(FLASH->SR, FLASH_SR_EOP)) {/* */}    /* wait until write op completes      */
    SET_REG_BIT(FLASH->SR, FLASH_SR_EOP);                     /* clear OPERATION COMPLETE flag      */

    OB->WRP2 = (uint16_t)0x00;                                /* write-protect pages 64 to 95       */
    while (!READ_REG_BIT(FLASH->SR, FLASH_SR_EOP)) {/* */}    /* wait until write op completes      */
    SET_REG_BIT(FLASH->SR, FLASH_SR_EOP);                     /* clear OPERATION COMPLETE flag      */

    OB->WRP3 = (uint16_t)0x80;                                /* write-protect pages 96 to 127      */
    while (!READ_REG_BIT(FLASH->SR, FLASH_SR_EOP)) {/* */}    /* wait until write op completes      */
    SET_REG_BIT(FLASH->SR, FLASH_SR_EOP);                     /* clear OPERATION COMPLETE flag      */

    OB->RDP = OB_RDP_LEVEL_1;                                 /* Enable read out protection         */
    while (!READ_REG_BIT(FLASH->SR, FLASH_SR_EOP)) {/* */}    /* wait until write op completes      */
    SET_REG_BIT(FLASH->SR, FLASH_SR_EOP);                     /* clear OPERATION COMPLETE flag      */

    CLEAR_REG_BIT(FLASH->CR, FLASH_CR_OPTPG);                 /* Disable OPT BYTE programming op.   */
    while (READ_REG_BIT(FLASH->SR, FLASH_SR_BSY)) {/* */}     /* Wait till no operation is on going */

    NVIC_SystemReset();                                       /* Reboot                             */
  }
#else
  #define FLASH_EN                      0
#endif


__STATIC_INLINE void init(void) {

  #define PORT_A_CONFIG (                         \\
    SPI_EN   * PIN_CFG(4,  O_10MHZ)               |           /* PA4:  SPI1 CS, output, 10MHz       */\\
    SPI_EN   * PIN_CFG(5,  O_AF + O_50MHZ)        |           /* PA5:  SPI1 CLK, alternate, 50MHz   */\\
    SPI_EN   * PIN_CFG(6,  I_PULL)                |           /* PA6:  SPI1 MISO, input, pull-down  */\\
    SPI_EN   * PIN_CFG(7,  O_AF + O_50MHZ)        |           /* PA7:  SPI1 MOSI, alternate, 50MHz  */\\
    EXTI_EN  * PIN_CFG(8,  I_PULL)                |           /* PA8:  EXTI Line, input, pull-up    */\\
    USART_EN * PIN_CFG(9,  O_AF + O_10MHZ)        |           /* PA9:  USART1 TX, alternate, 10MHz  */\\
    USART_EN * PIN_CFG(10, I_PULL)                |           /* PA10: USART1 RX, input, pull-down  */\\
    SWD_EN   * PIN_CFG(13, I_PULL)                |           /* PA13: SWDIO, input, pull-up        */\\
    SWD_EN   * PIN_CFG(14, I_PULL)                |           /* PA14: SWCLK, input, pull-down      */\\
    TIM2_EN  * PIN_CFG(15, O_AF + O_10MHZ)                    /* PA15: TIM2 CH2, alternate, 10MHz   */\\
  )

  #define PORT_A_STATE (                          \\
    SPI_EN   * PULL_UP(4)                         |           /* Pull-up SPI1 CS pin                */\\
    SPI_EN   * PULL_DOWN(6)                       |           /* Pull-down SPI1 MISO pin            */\\
    EXTI_EN  * PULL_UP(8)                         |           /* Pull-up EXTI pin                   */\\
    USART_EN * PULL_DOWN(10)                      |           /* Pull-down USART1 RX pin            */\\
    SWD_EN   * PULL_UP(13)                        |           /* Pull-up SWDIO pin                  */\\
    SWD_EN   * PULL_DOWN(14)                                  /* Pull-down SWCLK pin                */\\
  )

  #define IOPA_EN (PORT_A_CONFIG != 0)

  #define PORT_B_CONFIG (                         \\
    BTN_EN   * PIN_CFG(0,  I_PULL)                |           /* PB0:  BUTTON 1, input, pull-up     */\\
    BTN_EN   * PIN_CFG(1,  I_PULL)                |           /* PB1:  BUTTON 2, input, pull-up     */\\
    I2C_EN   * PIN_CFG(6,  O_AF + O_OD + O_10MHZ) |           /* PB6:  I2C1 SCL, altern, open drain */\\
    I2C_EN   * PIN_CFG(7,  O_AF + O_OD + O_10MHZ)             /* PB7:  I2C1 SDA, altern, open drain */\\
  )

  #define PORT_B_STATE (                          \\
    BTN_EN   * PULL_UP(0)                         |           /* Pull-up PB0 pin (BUTTON 1)         */\\
    BTN_EN   * PULL_UP(1)                                     /* Pull-up PB1 pin (BUTTON 2)         */\\
  )

  #define IOPB_EN (PORT_B_CONFIG != 0)

  #define PORT_C_CONFIG PIN_CFG(13, O_2MHZ)                   /* PC13: output, push-pull, 2Mhz      */
  #define PORT_C_STATE PIN_HIGH(13)                           /* Set PC13 pin HIGH (LED off)        */
  #define IOPC_EN (PORT_C_CONFIG != 0)

  #define GATE_CLOCK(BUS, PER)      RCC_ ## BUS ## ENR_ ## PER ## EN

  #define AHB_CONFIG (                            \\
    0        * GATE_CLOCK(AHB, DMA1)              |           /* Enable clock for DMA1              */\\
    0        * GATE_CLOCK(AHB, SRAM)              |           /* Enable clock for SRAM while Sleep  */\\
    0        * GATE_CLOCK(AHB, FLITF)             |           /* Enable clock for FLITF while Sleep */\\
    CRC_EN   * GATE_CLOCK(AHB, CRC)               |           /* Enable clock for CRC               */\\
    RNG_EN   * GATE_CLOCK(AHB, CRC)                           /* Enable clock for CRC               */\\
  )

  #define APB1_CONFIG (                           \\
    0        * GATE_CLOCK(APB1, TIM3)             |           /* Enable clock for Timer 3           */\\
    0        * GATE_CLOCK(APB1, TIM4)             |           /* Enable clock for Timer 4           */\\
    0        * GATE_CLOCK(APB1, CAN1)             |           /* Enable clock for CAN 1             */\\
    0        * GATE_CLOCK(APB1, SPI2)             |           /* Enable clock for SPI 2             */\\
    0        * GATE_CLOCK(APB1, USART2)           |           /* Enable clock for USART 2           */\\
    0        * GATE_CLOCK(APB1, USART3)           |           /* Enable clock for USART 3           */\\
    0        * GATE_CLOCK(APB1, I2C2)             |           /* Enable clock for I2C 2             */\\
    WWDG_EN  * GATE_CLOCK(APB1, WWDG)             |           /* Enable clock for Window Watchdog   */\\
    TIM2_EN  * GATE_CLOCK(APB1, TIM2)             |           /* Enable clock for Timer 2           */\\
    I2C_EN   * GATE_CLOCK(APB1, I2C1)             |           /* Enable clock for I2C 1             */\\
    RTC_EN   * GATE_CLOCK(APB1, BKP)              |           /* Enable clock for Backup interface  */\\
    RTC_EN   * GATE_CLOCK(APB1, PWR)                          /* Enable clock for Power interface   */\\
  )

  #define APB2_CONFIG (                           \\
    0        * GATE_CLOCK(APB2, TIM1)             |           /* Enable clock for Timer 1           */\\
    0        * GATE_CLOCK(APB2, ADC2)             |           /* Enable clock for ADC 1             */\\
    USART_EN * GATE_CLOCK(APB2, USART1)           |           /* Enable clock for USART 1           */\\
    SPI_EN   * GATE_CLOCK(APB2, SPI1)             |           /* Enable clock for SPI 1             */\\
    ADC_EN   * GATE_CLOCK(APB2, ADC1)             |           /* Enable clock for ADC 1             */\\
    IOPA_EN  * GATE_CLOCK(APB2, IOPA)             |           /* Enable clock for I/O port A        */\\
    IOPB_EN  * GATE_CLOCK(APB2, IOPB)             |           /* Enable clock for I/O port B        */\\
    IOPC_EN  * GATE_CLOCK(APB2, IOPC)             |           /* Enable clock for I/O port C        */\\
               GATE_CLOCK(APB2, AFIO)                         /* Enable clock for Alt. Function I/O */\\
  )

  #if AHB_CONFIG
    RCC->AHBENR = AHB_CONFIG;                                 /* Gate AHB clock if required         */
  #endif

  #if APB1_CONFIG
    RCC->APB1ENR = APB1_CONFIG;                               /* Gate APB1 clock if required        */
  #endif

  #if APB2_CONFIG
    RCC->APB2ENR = APB2_CONFIG;                               /* Gate APB2 clock if required        */
  #endif

  #if PORT_A_CONFIG
    *(__IO uint64_t*) GPIOA_BASE = PORT_A_CONFIG;             /* Init GPIOA if CONFIG is not empty  */
    #if PORT_A_STATE
      GPIOA->BSRR = PORT_A_STATE;                             /* Set GPIOA pins state if required   */
    #endif
  #endif

  #if PORT_B_CONFIG
    *(__IO uint64_t*) GPIOB_BASE = PORT_B_CONFIG;             /* Init GPIOB if CONFIG is not empty  */
    #if PORT_B_STATE
      GPIOB->BSRR = PORT_B_STATE;                             /* Set GPIOB pins state if required   */
    #endif
  #endif

  #if PORT_C_CONFIG
    *(__IO uint64_t*) GPIOC_BASE = PORT_C_CONFIG;             /* Init GPIOC if CONFIG is not empty  */
    #if PORT_C_STATE
      GPIOC->BSRR = PORT_C_STATE;                             /* Set GPIOC pins state if required   */
    #endif
  #endif

  AFIO->MAPR = (
    #if SWD_EN
      AFIO_MAPR_SWJ_CFG_JTAGDISABLE          |                /* Disable JTAG, enable SWD           */
    #else
      AFIO_MAPR_SWJ_CFG_DISABLE              |                /* Disable both JTAG and SWD          */
    #endif
    TIM2_EN * AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1      /* Remap CH1/PA15, CH2/PB3, CH3/PA2, CH4/PA3) */
  );

  #if HSE_EN
    SET_REG_BIT(RCC->CR, RCC_CR_HSEON);                       /* Switch HSE on                      */
    while(!READ_REG_BIT(RCC->CR, RCC_CR_HSERDY)) {/* */}      /* Wait until HSE becomes ready       */

    #if defined OVRCLK && OVRCLK != 0
      #define RCC_CFGR (                                      /* 112 MHz:                           */\\
                RCC_CFGR_PLLSRC                  |            /*   Pll Source is HSE                */\\
                RCC_CFGR_PLLMULL14               |            /*   Pll multiplier is 14             */\\
                RCC_CFGR_ADCPRE_DIV8                          /*   ADC clock divider is 8           */\\
              )
      #define HCLK     112000000UL
    #else
      #define RCC_CFGR (                                      /* 72 MHz:                            */\\
                RCC_CFGR_PLLSRC                  |            /*   Pll Source is HSE                */\\
                RCC_CFGR_PLLMULL9                |            /*   Pll multiplier is 9              */\\
                RCC_CFGR_ADCPRE_DIV6                          /*   ADC clock divider is 6           */\\
              )
      #define HCLK     72000000UL
    #endif

    #define RCC_CR   RCC_CR_PLLON | RCC_CR_HSEON
  #else
    #define RCC_CFGR RCC_CFGR_PLLMULL16                       /* 64 MHz: PllSrc = HSI / 2, Mul = 16 */
    #define RCC_CR   RCC_CR_PLLON
    #define HCLK     64000000UL
  #endif

  #if PLL_EN

    RCC->CFGR = RCC_CFGR;                                     /* Configure PLL                      */
    RCC->CR = RCC_CR;                                         /* Switch PLL on                      */
    while(!READ_REG_BIT(RCC->CR, RCC_CR_PLLRDY)) { /* */}     /* Wait until PLL becomes ready       */
    FLASH->ACR = FLASH_ACR_LATENCY_1;                         /* Set flash latency to 2             */
    RCC->CFGR = (
      RCC_CFGR             |
      RCC_CFGR_SW_PLL      |                                  /* Set PLL as system clock source     */
      RCC_CFGR_PPRE1_DIV2                                     /* Set APB1 clock as HCLK / 2         */
    );

    #define APB1_CLK ((HCLK) / 2)

  #else

    #undef  HCLK
    #define HCLK     8000000UL
    #define APB1_CLK HCLK

  #endif

  SysTick->LOAD = HCLK / 8000 - 1;                            /* Set SysTick reload register        */

  #if RNG_EN

    extern void srnd(unsigned);

    #if !RTC_EN && !ADC_EN
      SysTick->CTRL = SysTick_CTRL_ENABLE_Msk    |            /* Start SysTick timer (HCLK / 8)     */
                      SysTick_CTRL_CLKSOURCE_Msk |
                      SysTick_CTRL_TICKINT_Msk;               /* Enable SysTick exception request   */

      for(int i = 0; i < 10000; i++) {

        SET_REG_BIT(RCC->CSR, RCC_CSR_LSION);                 /* Enable LSI oscillator              */
        while(!READ_REG_BIT(RCC->CSR, RCC_CSR_LSION)) { }     /* wait till oscillator switches on   */
        CRC->DR = SysTick->VAL;                               /* process counter                    */

        CLEAR_REG_BIT(RCC->CSR, RCC_CSR_LSION);               /* Disable LSI oscillator             */
        while(READ_REG_BIT(RCC->CSR, RCC_CSR_LSION)) { }      /* wait till oscillator switches off  */
        CRC->DR = SysTick->VAL;                               /* process counter                    */
      }
      prnd();
      srnd(CRC->DR);
    #endif
  #endif

  SysTick->CTRL = SysTick_CTRL_ENABLE_Msk |                   /* Start SysTick timer (HCLK / 8)     */
                  SysTick_CTRL_TICKINT_Msk;                   /* Enable SysTick exception request   */

  #if USART_EN
    USART1->BRR = (HCLK + BAUDRATE / 2) / BAUDRATE;           /* Configure USART baud rate          */
    USART1->CR1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_UE; /* Enable USART peripheral            */
  #endif

  #if ADC_EN
    ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_TSVREFE | ADC_CR2_CONT;/* ADC enable, VrefInt enable, count  */

    DELAY_MS(2);                                              /* Before starting a calibration,
                                                                 the ADC must have been in power-on
                                                                 state for at least two ADC clock
                                                                 cycles.                            */

    SET_REG_BIT(ADC1->CR2, ADC_CR2_CAL);                      /* Start ADC1 calibration             */

    while (READ_REG_BIT(ADC1->CR2, ADC_CR2_CAL)) {
      /* Wait until ADC calibration completes */
    }

    /*
      The Temperature sensor is connected to channel ADCx_IN16 and the internal reference voltage
      VREFINT is connected to ADCx_IN17. These two internal channels can be selected and converted
      as injected or regular channels.
    */

    ADC1->SMPR1 = ADC_SMPR1(16, 239) | ADC_SMPR1(17, 239);
    ADC1->SQR3 = ADC_SQR3(1, 16);
    ADC1->SQR1 = ADC_SQR1_LEN(1);
                                                                                                    /*
      If any other bit in this register apart from ADON is changed at the same time,
      then conversion is not triggered. This is to prevent triggering an erroneous conversion.      */

    SET_REG_BIT(ADC1->CR2, ADC_CR2_ADON);                     /* Start continuous conversion        */

    #if RNG_EN
      unsigned rbits = 0;
      for(unsigned i = 0; i < 32; i++) {
        rbits = (rbits << 1) | adc_get_random_bit();
      }
      srnd(rbits);
    #endif

    #if 0
      /* ADC1 interrupt Init */
      NVIC_SetPriority(ADC1_2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));
      NVIC_ClearPendingIRQ(ADC1_2_IRQn);
      NVIC_EnableIRQ(ADC1_2_IRQn);
    #endif
  #endif

  #if I2C_EN
    I2C1->CCR = I2C_CCR;                                      /* Write CCR when I2C is disabled     */
    I2C1->TRISE = I2C_TRISE;                                  /* Maximum rise time in Fm/Sm mode    */
    I2C1->CR2 = APB1_CLK / 1000000;                           /* Configure Peripheral Clock Freq.   */
    I2C1->CR1 = I2C_CR1_PE;                                   /* Enable I2C1 Peripheral             */
  #endif

  #if SPI_EN
    SPI1->CR1 = (

      #if defined USE_PLL && USE_PLL != 0
        SPI_CR1_BR_0       |                                  /* Configure baudrate as HCLK / 4     */
      #endif

      SPI_CR1_MSTR         |                                  /* Select Master mode                 */
      SPI_CR1_SSM          |                                  /* Enable Software Slave Management   */
      SPI_CR1_SSI          |                                  /* Set Internal slave select bit      */
      SPI_CR1_SPE                                             /* Enable SPI1 Peripheral             */
    );
  #endif

  #if TIM2_EN

    #define TIM2_PSC 0          /* 0..0xFFFF - Prescaler Value                                      */
    #define TIM2_ARR 0          /* 0..0xFFFF - actual auto-reload Value                             */
    #define TIM2_CCR1 0x7FFF    /* 0..0xFFFF - Capture/Compare 1 Value                              */

    #define TIM2_EGR (    \\
      1 * TIM_EGR_UG      |  /* (1 << 0)    Update Generation                           0x00000001  */\\
      0 * TIM_EGR_CC1G    |  /* (1 << 1)    Capture/Compare 1 Generation                0x00000002  */\\
      0 * TIM_EGR_CC2G    |  /* (1 << 2)    Capture/Compare 2 Generation                0x00000004  */\\
      0 * TIM_EGR_CC3G    |  /* (1 << 3)    Capture/Compare 3 Generation                0x00000008  */\\
      0 * TIM_EGR_CC4G    |  /* (1 << 4)    Capture/Compare 4 Generation                0x00000010  */\\
      0 * TIM_EGR_COMG    |  /* (1 << 5)    Capture/Compare Control Update Generation   0x00000020  */\\
      0 * TIM_EGR_TG      |  /* (1 << 6)    Trigger Generation                          0x00000040  */\\
      0 * TIM_EGR_BG         /* (1 << 7)    Break Generation                            0x00000080  */\\
    )

    #define TIM2_DIER (   \\
      1 * TIM_DIER_UIE    |  /* (1 << 0)    Update interrupt enable                     0x00000001  */\\
      0 * TIM_DIER_CC1IE  |  /* (1 << 1)    Capture/Compare 1 interrupt enable          0x00000002  */\\
      0 * TIM_DIER_CC2IE  |  /* (1 << 2)    Capture/Compare 2 interrupt enable          0x00000004  */\\
      0 * TIM_DIER_CC3IE  |  /* (1 << 3)    Capture/Compare 3 interrupt enable          0x00000008  */\\
      0 * TIM_DIER_CC4IE  |  /* (1 << 4)    Capture/Compare 4 interrupt enable          0x00000010  */\\
                                                                                                      \\
      0 * TIM_DIER_TIE    |  /* (1 << 6)    Trigger interrupt enable                    0x00000040  */\\
                                                                                                      \\
      0 * TIM_DIER_UDE    |  /* (1 << 8)    Update DMA request enable                   0x00000100  */\\
      0 * TIM_DIER_CC1DE  |  /* (1 << 9)    Capture/Compare 1 DMA request enable        0x00000200  */\\
      0 * TIM_DIER_CC2DE  |  /* (1 << 10)   Capture/Compare 2 DMA request enable        0x00000400  */\\
      0 * TIM_DIER_CC3DE  |  /* (1 << 11)   Capture/Compare 3 DMA request enable        0x00000800  */\\
      0 * TIM_DIER_CC4DE  |  /* (1 << 12)   Capture/Compare 4 DMA request enable        0x00001000  */\\
                                                                                                      \\
      0 * TIM_DIER_TDE       /* (1 << 14)   Trigger DMA request enable                  0x00004000  */\\
    )

    #define TIM2_CCMR1 (     \\
      0 * TIM_CCMR1_CC1S     |  /* (3 << 0)    CC1S[1:0] bits (Capture/Compare 1 Sel.)  0x00000003  */\\
      0 * TIM_CCMR1_CC1S_0   |  /* (1 << 0)      0x00000001                                         */\\
      0 * TIM_CCMR1_CC1S_1   |  /* (2 << 0)      0x00000002                                         */\\
      0 * TIM_CCMR1_OC1FE    |  /* (1 << 2)    Output Compare 1 Fast enable             0x00000004  */\\
      0 * TIM_CCMR1_OC1PE    |  /* (1 << 3)    Output Compare 1 Preload enable          0x00000008  */\\
      0 * TIM_CCMR1_OC1M     |  /* (7 << 4)    OC1M[2:0] bits (Output Compare 1 Mode)   0x00000070  */\\
      0 * TIM_CCMR1_OC1M_0   |  /* (1 << 4)      0x00000010                                         */\\
      1 * TIM_CCMR1_OC1M_1   |  /* (2 << 4)      0x00000020                                         */\\
      1 * TIM_CCMR1_OC1M_2   |  /* (4 << 4)      0x00000040                                         */\\
      0 * TIM_CCMR1_OC1CE    |  /* (1 << 7)    Output Compare 1 Clear Enable            0x00000080  */\\
      0 * TIM_CCMR1_CC2S     |  /* (3 << 8)    CC2S[1:0] bits (Capture/Compare 2 Sel.)  0x00000300  */\\
      0 * TIM_CCMR1_CC2S_0   |  /* (1 << 8)      0x00000100                                         */\\
      0 * TIM_CCMR1_CC2S_1   |  /* (2 << 8)      0x00000200                                         */\\
      0 * TIM_CCMR1_OC2FE    |  /* (1 << 10)   Output Compare 2 Fast enable             0x00000400  */\\
      0 * TIM_CCMR1_OC2PE    |  /* (1 << 11)   Output Compare 2 Preload enable          0x00000800  */\\
      0 * TIM_CCMR1_OC2M     |  /* (7 << 12)   OC2M[2:0] bits (Output Compare 2 Mode)   0x00007000  */\\
      0 * TIM_CCMR1_OC2M_0   |  /* (1 << 12)     0x00001000                                         */\\
      0 * TIM_CCMR1_OC2M_1   |  /* (2 << 12)     0x00002000                                         */\\
      0 * TIM_CCMR1_OC2M_2   |  /* (4 << 12)     0x00004000                                         */\\
      0 * TIM_CCMR1_OC2CE    |  /* (1 << 15)   Output Compare 2 Clear Enable            0x00008000  */\\
      0 * TIM_CCMR1_IC1PSC   |  /* (3 << 2)    IC1PSC[1:0] bits (Input Capture 1 Psc.)  0x0000000C  */\\
      0 * TIM_CCMR1_IC1PSC_0 |  /* (1 << 2)      0x00000004                                         */\\
      0 * TIM_CCMR1_IC1PSC_1 |  /* (2 << 2)      0x00000008                                         */\\
      0 * TIM_CCMR1_IC1F     |  /* (0xF << 4)  IC1F[3:0] bits (Input Capture 1 Filter)  0x000000F0  */\\
      0 * TIM_CCMR1_IC1F_0   |  /* (1 << 4)      0x00000010                                         */\\
      0 * TIM_CCMR1_IC1F_1   |  /* (2 << 4)      0x00000020                                         */\\
      0 * TIM_CCMR1_IC1F_2   |  /* (4 << 4)      0x00000040                                         */\\
      0 * TIM_CCMR1_IC1F_3   |  /* (8 << 4)      0x00000080                                         */\\
      0 * TIM_CCMR1_IC2PSC   |  /* (3 << 10)   IC2PSC[1:0] bits (Input Capture 2 Psc.)  0x00000C00  */\\
      0 * TIM_CCMR1_IC2PSC_0 |  /* (1 << 10)     0x00000400                                         */\\
      0 * TIM_CCMR1_IC2PSC_1 |  /* (2 << 10)     0x00000800                                         */\\
      0 * TIM_CCMR1_IC2F     |  /* (0xF << 12) IC2F[3:0] bits (Input Capture 2 Filter)  0x0000F000  */\\
      0 * TIM_CCMR1_IC2F_0   |  /* (1 << 12)     0x00001000                                         */\\
      0 * TIM_CCMR1_IC2F_1   |  /* (2 << 12)     0x00002000                                         */\\
      0 * TIM_CCMR1_IC2F_2   |  /* (4 << 12)     0x00004000                                         */\\
      0 * TIM_CCMR1_IC2F_3      /* (8 << 12)     0x00008000                                         */\\
    )

    #define TIM2_CCER (      \\
      1 * TIM_CCER_CC1E      |  /* (1 << 0)   Capture/Compare 1 output enable           0x00000001  */\\
      0 * TIM_CCER_CC1P      |  /* (1 << 1)   Capture/Compare 1 output Polarity         0x00000002  */\\
                                                                                                      \\
      0 * TIM_CCER_CC2E      |  /* (1 << 4)   Capture/Compare 2 output enable           0x00000010  */\\
      0 * TIM_CCER_CC2P      |  /* (1 << 5)   Capture/Compare 2 output Polarity         0x00000020  */\\
                                                                                                      \\
      0 * TIM_CCER_CC3E      |  /* (1 << 8)   Capture/Compare 3 output enable           0x00000100  */\\
      0 * TIM_CCER_CC3P      |  /* (1 << 9)   Capture/Compare 3 output Polarity         0x00000200  */\\
                                                                                                      \\
      0 * TIM_CCER_CC4E      |  /* (1 << 12)  Capture/Compare 4 output enable           0x00001000  */\\
      0 * TIM_CCER_CC4P         /* (1 << 13)  Capture/Compare 4 output Polarity         0x00002000  */\\
    )

    NVIC_SetPriority(TIM2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));
    NVIC_ClearPendingIRQ(TIM2_IRQn);
    NVIC_EnableIRQ(TIM2_IRQn);                                /* Enable TIM2 Interrupt              */

    #define TIM2_CR1 (  \\
      1 * TIM_CR1_CEN   |  /* (1 << 0)  Counter enable                                0x00000001    */\\
      0 * TIM_CR1_UDIS  |  /* (1 << 1)  Update disable                                0x00000002    */\\
      0 * TIM_CR1_URS   |  /* (1 << 2)  Update request source                         0x00000004    */\\
      0 * TIM_CR1_OPM   |  /* (1 << 3)  One pulse mode                                0x00000008    */\\
      0 * TIM_CR1_DIR   |  /* (1 << 4)  Direction                                     0x00000010    */\\
      0 * TIM_CR1_CMS   |  /* (3 << 5)  CMS[1:0] bits (Center-aligned mode selection) 0x00000060    */\\
      0 * TIM_CR1_CMS_0 |  /* (1 << 5)    0x00000020                                                */\\
      0 * TIM_CR1_CMS_1 |  /* (2 << 5)    0x00000040                                                */\\
      0 * TIM_CR1_ARPE  |  /* (1 << 7)  Auto-reload preload enable                    0x00000080    */\\
      0 * TIM_CR1_CKD   |  /* (3 << 8)  CKD[1:0] bits (clock division)                0x00000300    */\\
      0 * TIM_CR1_CKD_0 |  /* (1 << 8)    0x00000100                                                */\\
      0 * TIM_CR1_CKD_1    /* (2 << 8)    0x00000200                                                */\\
    )

    #if TIM2_ARR != 0
      TIM2->ARR = TIM2_ARR;  /* 0x4000002C: TIM2 auto-reload register                               */
    #endif

    #if TIM2_CCR1 != 0
      TIM2->CCR1 = TIM2_CCR1;/* 0x40000034: TIM2 capture/compare register 1                         */
    #endif

    #if TIM2_PSC != 0
      TIM2->PSC = TIM2_PSC;  /* 0x40000028: TIM2 prescaler register                                 */
      #if TIM2_EGR != 0
        TIM2->EGR = TIM2_EGR;/* 0x40000014: TIM2 event generation register                          */
        TIM2->SR = 0;        /* Reset TIM2 status flags                                             */
      #endif
    #endif

    #if TIM2_DIER != 0
      TIM2->DIER = TIM2_DIER;/* 0x4000000C: TIM DMA/interrupt enable register                       */
    #endif

    #if TIM2_CCMR1 != 0
      TIM2->CCMR1 = TIM2_CCMR1; /* 0x40000018: TIM2 capt/comp mode register 1                       */
    #endif

    #if TIM2_CCER != 0
      TIM2->CCER = TIM2_CCER;   /* 0x40000020: TIM capture/compare enable register                  */
    #endif

    #if TIM2_CR1 != 0
      TIM2->CR1 = TIM2_CR1;/* 0x40000000: TIM control register 1                                    */
    #endif

  #endif

  #if RTC_EN

    SET_REG_BIT(PWR->CR, PWR_CR_DBP);                         /* Disable Backup Domain write prot.  */

    #if !LSE_EN && !HSE_EN
      SET_REG_BIT(RCC->CSR, RCC_CSR_LSION);                   /* Enable LSI oscillator              */
    #endif

    unsigned is_rtc_enabled = READ_REG_BIT(RCC->BDCR, RCC_BDCR_RTCEN);

    RCC->BDCR = (
      #if LSE_EN
        RCC_BDCR_LSEON           |                            /* Enable LSE oscillator              */
        RCC_BDCR_RTCSEL_LSE      |                            /* LSE used as RTC clock              */
      #elif HSE_EN
        RCC_BDCR_RTCSEL_HSE      |                            /* HSE / 128 used as RTC clock        */
      #else
        RCC_BDCR_RTCSEL_LSI      |                            /* LSI used as RTC clock              */
      #endif

      RCC_BDCR_RTCEN                                          /* RTC clock enable                   */
    );
                                                                                                    /*
      Configuration procedure
      =======================
      1. Poll RTOFF, wait until its value goes to '1'
      2. Set the CNF bit to enter configuration mode
      3. Write to one or more RTC registers
      4. Clear the CNF bit to exit configuration mode
      5. Poll RTOFF, wait until its value goes to '1' to check the end of the write operation.

      The write operation only executes when the CNF bit is cleared; it takes at least three
      RTCCLK cycles to complete.                                                                    */

    /* 1. */
    while(!READ_REG_BIT(RTC->CRL, RTC_CRL_RTOFF)) {
      /* wait until the last write operation completes */
    }

    /* 2. */
    SET_REG_BIT(RTC->CRL, RTC_CRL_CNF);

    #if USE_LSE
      /* 3. */
                                                                                                    /*
      Note: If the input clock frequency (fRTCCLK) is 32.768 kHz, write 7FFFh in this register to
            get a signal period of 1 second.
                                                                                                    */
      RTC->PRLH = 0;
      RTC->PRLL = 0x7FFF;
    #elif USE_HSE
      RTC->PRLH = 0;
      RTC->PRLL = 0xF423;
    #else
      RTC->PRLH = 0;
      RTC->PRLL = 0x9CC0; // 0x9C3F
    #endif

    if (!is_rtc_enabled) {
      #define RTC_CNT 1620191105     /* Epoch timestamp: 1620191105 = Wed, 05 May 2021 05:05:05 GMT */

      RTC->CNTH = RTC_CNT >> 16;                              /* Set RTC Counter MS word            */
      RTC->CNTL = RTC_CNT & 0xFFFF;                           /* Set RTC Counter LS word            */
    }

    unsigned rtc_data = rtc_read_counter() + 25000;

    RTC->ALRH = rtc_data >> 16;                               /* Set RTC Alarm Register MS word     */
    RTC->ALRL = rtc_data & 0xFFFF;                            /* Set RTC Alarm Register LS word     */

    RTC->CRH = (
      RTC_CRH_ALRIE   |                                       /* Enable RTC Alarm interrupt         */
      RTC_CRH_SECIE                                           /* Enable RTC Second interrupt        */
    );

    /* 4. The write operation is only executed when the CNF bit is reset by software after has been set. */
    CLEAR_REG_BIT(RTC->CRL, RTC_CRL_CNF);

    /* 5. */
    while(!READ_REG_BIT(RTC->CRL, RTC_CRL_RTOFF)) {
      /* wait until the last write operation completes */
    }

    /* Note: If the HSE divided by 128 is used as the RTC clock, this bit must remain set to 1.     */
    #if LSE_EN || !HSE_EN
      CLEAR_REG_BIT(PWR->CR, PWR_CR_DBP);                     /* Restore Backup Domain write prot.  */
    #endif

    #if RNG_EN && !ADC_EN
      CRC->DR = rtc_read_counter();
      srnd(prnd());
    #endif

    NVIC_SetPriority(RTC_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));
    NVIC_ClearPendingIRQ(RTC_IRQn);
    NVIC_EnableIRQ(RTC_IRQn);

    /* EXTI line 17 is connected to the RTC Alarm event  */

    /* Configure exti and nvic for RTC IT                */
    /* (13) unmask line 17                               */
    /* (14) Rising edge for line 17                      */
    /* (15) Clear pending request line 17                */

    /* (16) Set priority                                 */
    /* (17) Enable RTC_IRQn                              */


    SET_REG_BIT(EXTI->IMR, EXTI_IMR_MR17);       /* (13) */
    SET_REG_BIT(EXTI->RTSR, EXTI_RTSR_TR17);     /* (14) */
    SET_REG_BIT(EXTI->PR, EXTI_PR_PR17);

    NVIC_SetPriority(RTC_Alarm_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));
    NVIC_ClearPendingIRQ(RTC_Alarm_IRQn);
    NVIC_EnableIRQ(RTC_Alarm_IRQn);                           /* Enable RTC Alarm EXTI Interrupt    */

  #endif /* USE_RTC */

  #if IWDG_EN

    #if RTC_EN && !LSE_EN && !HSE_EN
      /* */
    #else
      SET_REG_BIT(RCC->CSR, RCC_CSR_LSION);                   /* Enable LSI oscillator              */
    #endif

    while(!READ_REG_BIT(RCC->CSR, RCC_CSR_LSIRDY)) {
      /* wait until LSI oscillations become stable */
    }
    IWDG->KR = 0x5555;
                                                                                                    /*
      Min/max IWDG timeout period (in ms) at 40 kHz (LSI)(1)
    =======================================================================
      Prescaler      PR[2:0] bits       Min timeout         Max timeout
       divider                        RL[11:0]= 0x000     RL[11:0]= 0xFFF

          /4              0                 0.1                409.6
          /8              1                 0.2                819.2
         /16              2                 0.4               1638.4
         /32              3                 0.8               3276.8
         /64              4                 1.6               6553.6
        /128              5                 3.2              13107.2
        /256              6 (or 7)          6.4              26214.4
    =======================================================================                         */

    IWDG->PR = 2;
    IWDG->RLR = 0xFFF;

    IWDG->KR = 0xCCCC;                                        /*  Start the watchdog                */
  #endif /* IWDG_EN */

  #if WWDG_EN

    NVIC_SetPriority(WWDG_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));
    NVIC_ClearPendingIRQ(WWDG_IRQn);
    NVIC_EnableIRQ(WWDG_IRQn);

    WWDG->CR = WWDG_CR_WDGA                                   /* When WDGA=1, WWDG reset is enabled */
             | WWDG_COUNTER;                                  /* 7-bit counter (MSB to LSB).        */
                                                              /* It is decremented every            */
                                                              /* 4096 * 2 ^ WDGTB[1:0] PCLK1 cycles */
                                                              /* A reset is produced when it rolls  */
                                                              /* over from 0x40 to 0x3F             */
                                                              /* (T6 becomes cleared)               */

    WWDG->CFR = (
      1 * WWDG_CFR_EWI        |                               /* Early wakeup interrupt             */
      1 * WWDG_CFR_WDGTB_0    |                               /* Timer base bit 0                   */
      1 * WWDG_CFR_WDGTB_1    |                               /* Timer base bit 1                   */
      1 * WWDG_WINDOW                                         /* Watchdoeg Window                   */
    );
  #endif

  #if EXTI_EN

    #define INIT_AFIO_EXTICR_0   (     \\
      0 * AFIO_EXTICR1_EXTI0           | /*  0x0000000F EXTI 0 configuration                        */\\
      0 * AFIO_EXTICR1_EXTI1           | /*  0x000000F0 EXTI 1 configuration                        */\\
      0 * AFIO_EXTICR1_EXTI2           | /*  0x00000F00 EXTI 2 configuration                        */\\
      0 * AFIO_EXTICR1_EXTI3           | /*  0x0000F000 EXTI 3 configuration                        */\\
                                                                                                      \\
      0 * AFIO_EXTICR1_EXTI0_PA        | /*  0x00000000 PA[0] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI0_PB        | /*  0x00000001 PB[0] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI0_PC        | /*  0x00000002 PC[0] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI0_PD        | /*  0x00000003 PD[0] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI0_PE        | /*  0x00000004 PE[0] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI0_PF        | /*  0x00000005 PF[0] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI0_PG        | /*  0x00000006 PG[0] pin                                   */\\
                                                                                                      \\
      0 * AFIO_EXTICR1_EXTI1_PA        | /*  0x00000000 PA[1] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI1_PB        | /*  0x00000010 PB[1] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI1_PC        | /*  0x00000020 PC[1] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI1_PD        | /*  0x00000030 PD[1] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI1_PE        | /*  0x00000040 PE[1] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI1_PF        | /*  0x00000050 PF[1] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI1_PG        | /*  0x00000060 PG[1] pin                                   */\\
                                                                                                      \\
      0 * AFIO_EXTICR1_EXTI2_PA        | /*  0x00000000 PA[2] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI2_PB        | /*  0x00000100 PB[2] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI2_PC        | /*  0x00000200 PC[2] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI2_PD        | /*  0x00000300 PD[2] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI2_PE        | /*  0x00000400 PE[2] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI2_PF        | /*  0x00000500 PF[2] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI2_PG        | /*  0x00000600 PG[2] pin                                   */\\
                                                                                                      \\
      0 * AFIO_EXTICR1_EXTI3_PA        | /*  0x00000000 PA[3] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI3_PB        | /*  0x00001000 PB[3] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI3_PC        | /*  0x00002000 PC[3] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI3_PD        | /*  0x00003000 PD[3] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI3_PE        | /*  0x00004000 PE[3] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI3_PF        | /*  0x00005000 PF[3] pin                                   */\\
      0 * AFIO_EXTICR1_EXTI3_PG          /*  0x00006000 PG[3] pin                                   */\\
    )

    #define INIT_AFIO_EXTICR_1   (     \\
      0 * AFIO_EXTICR2_EXTI4           | /*  0x0000000F EXTI 4 configuration                        */\\
      0 * AFIO_EXTICR2_EXTI5           | /*  0x000000F0 EXTI 5 configuration                        */\\
      0 * AFIO_EXTICR2_EXTI6           | /*  0x00000F00 EXTI 6 configuration                        */\\
      0 * AFIO_EXTICR2_EXTI7           | /*  0x0000F000 EXTI 7 configuration                        */\\
                                                                                                      \\
      0 * AFIO_EXTICR2_EXTI4_PA        | /*  0x00000000 PA[4] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI4_PB        | /*  0x00000001 PB[4] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI4_PC        | /*  0x00000002 PC[4] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI4_PD        | /*  0x00000003 PD[4] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI4_PE        | /*  0x00000004 PE[4] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI4_PF        | /*  0x00000005 PF[4] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI4_PG        | /*  0x00000006 PG[4] pin                                   */\\
                                                                                                      \\
      0 * AFIO_EXTICR2_EXTI5_PA        | /*  0x00000000 PA[5] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI5_PB        | /*  0x00000010 PB[5] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI5_PC        | /*  0x00000020 PC[5] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI5_PD        | /*  0x00000030 PD[5] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI5_PE        | /*  0x00000040 PE[5] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI5_PF        | /*  0x00000050 PF[5] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI5_PG        | /*  0x00000060 PG[5] pin                                   */\\
                                                                                                      \\
      0 * AFIO_EXTICR2_EXTI6_PA        | /*  0x00000000 PA[6] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI6_PB        | /*  0x00000100 PB[6] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI6_PC        | /*  0x00000200 PC[6] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI6_PD        | /*  0x00000300 PD[6] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI6_PE        | /*  0x00000400 PE[6] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI6_PF        | /*  0x00000500 PF[6] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI6_PG        | /*  0x00000600 PG[6] pin                                   */\\
                                                                                                      \\
      0 * AFIO_EXTICR2_EXTI7_PA        | /*  0x00000000 PA[7] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI7_PB        | /*  0x00001000 PB[7] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI7_PC        | /*  0x00002000 PC[7] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI7_PD        | /*  0x00003000 PD[7] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI7_PE        | /*  0x00004000 PE[7] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI7_PF        | /*  0x00005000 PF[7] pin                                   */\\
      0 * AFIO_EXTICR2_EXTI7_PG          /*  0x00006000 PG[7] pin                                   */\\
    )

    #define INIT_AFIO_EXTICR_2   (     \\
      0 * AFIO_EXTICR3_EXTI8           | /*  0x0000000F EXTI 8 configuration                        */\\
      0 * AFIO_EXTICR3_EXTI9           | /*  0x000000F0 EXTI 9 configuration                        */\\
      0 * AFIO_EXTICR3_EXTI10          | /*  0x00000F00 EXTI 10 configuration                       */\\
      0 * AFIO_EXTICR3_EXTI11          | /*  0x0000F000 EXTI 11 configuration                       */\\
                                                                                                      \\
      1 * AFIO_EXTICR3_EXTI8_PA        | /*  0x00000000 PA[8] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI8_PB        | /*  0x00000001 PB[8] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI8_PC        | /*  0x00000002 PC[8] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI8_PD        | /*  0x00000003 PD[8] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI8_PE        | /*  0x00000004 PE[8] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI8_PF        | /*  0x00000005 PF[8] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI8_PG        | /*  0x00000006 PG[8] pin                                   */\\
                                                                                                      \\
      0 * AFIO_EXTICR3_EXTI9_PA        | /*  0x00000000 PA[9] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI9_PB        | /*  0x00000010 PB[9] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI9_PC        | /*  0x00000020 PC[9] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI9_PD        | /*  0x00000030 PD[9] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI9_PE        | /*  0x00000040 PE[9] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI9_PF        | /*  0x00000050 PF[9] pin                                   */\\
      0 * AFIO_EXTICR3_EXTI9_PG        | /*  0x00000060 PG[9] pin                                   */\\
                                                                                                      \\
      0 * AFIO_EXTICR3_EXTI10_PA       | /*  0x00000000 PA[10] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI10_PB       | /*  0x00000100 PB[10] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI10_PC       | /*  0x00000200 PC[10] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI10_PD       | /*  0x00000300 PD[10] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI10_PE       | /*  0x00000400 PE[10] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI10_PF       | /*  0x00000500 PF[10] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI10_PG       | /*  0x00000600 PG[10] pin                                  */\\
                                                                                                      \\
      0 * AFIO_EXTICR3_EXTI11_PA       | /*  0x00000000 PA[11] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI11_PB       | /*  0x00001000 PB[11] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI11_PC       | /*  0x00002000 PC[11] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI11_PD       | /*  0x00003000 PD[11] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI11_PE       | /*  0x00004000 PE[11] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI11_PF       | /*  0x00005000 PF[11] pin                                  */\\
      0 * AFIO_EXTICR3_EXTI11_PG         /*  0x00006000 PG[11] pin                                  */\\
    )

    #define INIT_AFIO_EXTICR_3   (     \\
      0 * AFIO_EXTICR4_EXTI12          | /*  0x0000000F EXTI 12 configuration                       */\\
      0 * AFIO_EXTICR4_EXTI13          | /*  0x000000F0 EXTI 13 configuration                       */\\
      0 * AFIO_EXTICR4_EXTI14          | /*  0x00000F00 EXTI 14 configuration                       */\\
      0 * AFIO_EXTICR4_EXTI15          | /*  0x0000F000 EXTI 15 configuration                       */\\
                                                                                                      \\
      0 * AFIO_EXTICR4_EXTI12_PA       | /*  0x00000000 PA[12] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI12_PB       | /*  0x00000001 PB[12] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI12_PC       | /*  0x00000002 PC[12] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI12_PD       | /*  0x00000003 PD[12] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI12_PE       | /*  0x00000004 PE[12] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI12_PF       | /*  0x00000005 PF[12] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI12_PG       | /*  0x00000006 PG[12] pin                                  */\\
                                                                                                      \\
      0 * AFIO_EXTICR4_EXTI13_PA       | /*  0x00000000 PA[13] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI13_PB       | /*  0x00000010 PB[13] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI13_PC       | /*  0x00000020 PC[13] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI13_PD       | /*  0x00000030 PD[13] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI13_PE       | /*  0x00000040 PE[13] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI13_PF       | /*  0x00000050 PF[13] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI13_PG       | /*  0x00000060 PG[13] pin                                  */\\
                                                                                                      \\
      0 * AFIO_EXTICR4_EXTI14_PA       | /*  0x00000000 PA[14] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI14_PB       | /*  0x00000100 PB[14] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI14_PC       | /*  0x00000200 PC[14] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI14_PD       | /*  0x00000300 PD[14] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI14_PE       | /*  0x00000400 PE[14] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI14_PF       | /*  0x00000500 PF[14] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI14_PG       | /*  0x00000600 PG[14] pin                                  */\\
                                                                                                      \\
      0 * AFIO_EXTICR4_EXTI15_PA       | /*  0x00000000 PA[15] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI15_PB       | /*  0x00001000 PB[15] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI15_PC       | /*  0x00002000 PC[15] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI15_PD       | /*  0x00003000 PD[15] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI15_PE       | /*  0x00004000 PE[15] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI15_PF       | /*  0x00005000 PF[15] pin                                  */\\
      0 * AFIO_EXTICR4_EXTI15_PG         /*  0x00006000 PG[15] pin                                  */\\
    )

    #define INIT_EXTI_IMR        (     \\
      0 * EXTI_IMR_MR0                 | /*  0x00000001 Interrupt Mask on line 0                    */\\
      0 * EXTI_IMR_MR1                 | /*  0x00000002 Interrupt Mask on line 1                    */\\
      0 * EXTI_IMR_MR2                 | /*  0x00000004 Interrupt Mask on line 2                    */\\
      0 * EXTI_IMR_MR3                 | /*  0x00000008 Interrupt Mask on line 3                    */\\
      0 * EXTI_IMR_MR4                 | /*  0x00000010 Interrupt Mask on line 4                    */\\
      0 * EXTI_IMR_MR5                 | /*  0x00000020 Interrupt Mask on line 5                    */\\
      0 * EXTI_IMR_MR6                 | /*  0x00000040 Interrupt Mask on line 6                    */\\
      0 * EXTI_IMR_MR7                 | /*  0x00000080 Interrupt Mask on line 7                    */\\
      1 * EXTI_IMR_MR8                 | /*  0x00000100 Interrupt Mask on line 8                    */\\
      0 * EXTI_IMR_MR9                 | /*  0x00000200 Interrupt Mask on line 9                    */\\
      0 * EXTI_IMR_MR10                | /*  0x00000400 Interrupt Mask on line 10                   */\\
      0 * EXTI_IMR_MR11                | /*  0x00000800 Interrupt Mask on line 11                   */\\
      0 * EXTI_IMR_MR12                | /*  0x00001000 Interrupt Mask on line 12                   */\\
      0 * EXTI_IMR_MR13                | /*  0x00002000 Interrupt Mask on line 13                   */\\
      0 * EXTI_IMR_MR14                | /*  0x00004000 Interrupt Mask on line 14                   */\\
      0 * EXTI_IMR_MR15                | /*  0x00008000 Interrupt Mask on line 15                   */\\
      0 * EXTI_IMR_MR16                | /*  0x00010000 Interrupt Mask on line 16                   */\\
      0 * EXTI_IMR_MR17                | /*  0x00020000 Interrupt Mask on line 17                   */\\
      0 * EXTI_IMR_MR18                  /*  0x00040000 Interrupt Mask on line 18                   */\\
    )

    #define INIT_EXTI_RTSR       (     \\
      0 * EXTI_RTSR_TR0                | /*  0x00000001 Configure Rising edge trigger for line 0    */\\
      0 * EXTI_RTSR_TR1                | /*  0x00000002 Configure Rising edge trigger for line 1    */\\
      0 * EXTI_RTSR_TR2                | /*  0x00000004 Configure Rising edge trigger for line 2    */\\
      0 * EXTI_RTSR_TR3                | /*  0x00000008 Configure Rising edge trigger for line 3    */\\
      0 * EXTI_RTSR_TR4                | /*  0x00000010 Configure Rising edge trigger for line 4    */\\
      0 * EXTI_RTSR_TR5                | /*  0x00000020 Configure Rising edge trigger for line 5    */\\
      0 * EXTI_RTSR_TR6                | /*  0x00000040 Configure Rising edge trigger for line 6    */\\
      0 * EXTI_RTSR_TR7                | /*  0x00000080 Configure Rising edge trigger for line 7    */\\
      0 * EXTI_RTSR_TR8                | /*  0x00000100 Configure Rising edge trigger for line 8    */\\
      0 * EXTI_RTSR_TR9                | /*  0x00000200 Configure Rising edge trigger for line 9    */\\
      0 * EXTI_RTSR_TR10               | /*  0x00000400 Configure Rising edge trigger for line 10   */\\
      0 * EXTI_RTSR_TR11               | /*  0x00000800 Configure Rising edge trigger for line 11   */\\
      0 * EXTI_RTSR_TR12               | /*  0x00001000 Configure Rising edge trigger for line 12   */\\
      0 * EXTI_RTSR_TR13               | /*  0x00002000 Configure Rising edge trigger for line 13   */\\
      0 * EXTI_RTSR_TR14               | /*  0x00004000 Configure Rising edge trigger for line 14   */\\
      0 * EXTI_RTSR_TR15               | /*  0x00008000 Configure Rising edge trigger for line 15   */\\
      0 * EXTI_RTSR_TR16               | /*  0x00010000 Configure Rising edge trigger for line 16   */\\
      0 * EXTI_RTSR_TR17               | /*  0x00020000 Configure Rising edge trigger for line 17   */\\
      0 * EXTI_RTSR_TR18                 /*  0x00040000 Configure Rising edge trigger for line 18   */\\
    )

    #define INIT_EXTI_FTSR       (     \\
      0 * EXTI_FTSR_TR0                | /*  0x00000001 Configure Falling edge trigger for line 0   */\\
      0 * EXTI_FTSR_TR1                | /*  0x00000002 Configure Falling edge trigger for line 1   */\\
      0 * EXTI_FTSR_TR2                | /*  0x00000004 Configure Falling edge trigger for line 2   */\\
      0 * EXTI_FTSR_TR3                | /*  0x00000008 Configure Falling edge trigger for line 3   */\\
      0 * EXTI_FTSR_TR4                | /*  0x00000010 Configure Falling edge trigger for line 4   */\\
      0 * EXTI_FTSR_TR5                | /*  0x00000020 Configure Falling edge trigger for line 5   */\\
      0 * EXTI_FTSR_TR6                | /*  0x00000040 Configure Falling edge trigger for line 6   */\\
      0 * EXTI_FTSR_TR7                | /*  0x00000080 Configure Falling edge trigger for line 7   */\\
      1 * EXTI_FTSR_TR8                | /*  0x00000100 Configure Falling edge trigger for line 8   */\\
      0 * EXTI_FTSR_TR9                | /*  0x00000200 Configure Falling edge trigger for line 9   */\\
      0 * EXTI_FTSR_TR10               | /*  0x00000400 Configure Falling edge trigger for line 10  */\\
      0 * EXTI_FTSR_TR11               | /*  0x00000800 Configure Falling edge trigger for line 11  */\\
      0 * EXTI_FTSR_TR12               | /*  0x00001000 Configure Falling edge trigger for line 12  */\\
      0 * EXTI_FTSR_TR13               | /*  0x00002000 Configure Falling edge trigger for line 13  */\\
      0 * EXTI_FTSR_TR14               | /*  0x00004000 Configure Falling edge trigger for line 14  */\\
      0 * EXTI_FTSR_TR15               | /*  0x00008000 Configure Falling edge trigger for line 15  */\\
      0 * EXTI_FTSR_TR16               | /*  0x00010000 Configure Falling edge trigger for line 16  */\\
      0 * EXTI_FTSR_TR17               | /*  0x00020000 Configure Falling edge trigger for line 17  */\\
      0 * EXTI_FTSR_TR18                 /*  0x00040000 Configure Falling edge trigger for line 18  */\\
    )

    #if INIT_AFIO_EXTICR_0
      AFIO->EXTICR[0] = INIT_AFIO_EXTICR_0;
    #endif

    #if INIT_AFIO_EXTICR_1
      AFIO->EXTICR[1] = INIT_AFIO_EXTICR_1;
    #endif

    #if INIT_AFIO_EXTICR_2
      AFIO->EXTICR[2] = INIT_AFIO_EXTICR_2;
    #endif

    #if INIT_AFIO_EXTICR_3
      AFIO->EXTICR[3] = INIT_AFIO_EXTICR_3;
    #endif

    #if INIT_EXTI_IMR
      EXTI->IMR = INIT_EXTI_IMR;
    #endif

    #if INIT_EXTI_RTSR
      EXTI->RTSR = INIT_EXTI_RTSR;
    #endif

    #if INIT_EXTI_FTSR
      EXTI->FTSR = INIT_EXTI_FTSR;
    #endif

    NVIC_SetPriority(EXTI9_5_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));
    NVIC_ClearPendingIRQ(EXTI9_5_IRQn);
    NVIC_EnableIRQ(EXTI9_5_IRQn);
  #endif

}  /* void init(void) */

#define HEX(NIBBLE) (((NIBBLE) < 10) ? (NIBBLE) + '0' : (NIBBLE) + '7')

#if USART_EN
  __STATIC_INLINE void uputc(char c) {
    /*** Send char using USART1 ***/
    while (!READ_REG_BIT(USART1->SR, USART_SR_TXE)) {}                 /* Wait until TX register becomes empty */
    USART1->DR = c;
  }

  __STATIC_INLINE void uputs(char *c) {
    /*** Send string using UART ***/
    while(*c) {
      uputc(*c++);
    }
  }

  __STATIC_INLINE void uput_x(const uint8_t c) {
    /*** Convert a nibble to HEX and send it via UART ***/
    uputc(HEX(c));
  }

  __STATIC_INLINE void uputx(const uint8_t c) {
    /* Convert a byte to HEX and send it via UART */
    uput_x(c >> 4);
    uput_x(c & 0x0F);
  }

  #define uprintf(...) do{char _[160]; snprintf(_, sizeof(_), __VA_ARGS__); uputs(_);}while(0)
#else
  #define uprintf(...)
#endif

#if I2C_EN

  #define I2C_TIMEOUT     10
  #define I2C_ERR_TIMEOUT 1
  #define I2C_ERROR       (                                                            \\
                            I2C_SR1_BERR  |  /*  Bus Error            (0x00000100)   */\\
                            I2C_SR1_ARLO  |  /*  Arbitration Lost     (0x00000200)   */\\
                            I2C_SR1_AF    |  /*  Acknowledge Failure  (0x00000400)   */\\
                            I2C_SR1_OVR      /*  Overrun/Underrun     (0x00000800)   */\\
                          )

  extern unsigned short i2c_status;

  __STATIC_INLINE ErrorStatus i2c_check(const unsigned bitFlag) {
    unsigned t_out = I2C_TIMEOUT;
    (void) SysTick->CTRL;

    while((I2C1->SR1 & bitFlag) == 0) {
      t_out -= GET_TICK();
      if (t_out == 0) {
        i2c_status |= I2C_ERR_TIMEOUT;
        return ERROR;
      }

      unsigned e_status = I2C1->SR1 & I2C_ERROR;
      if (e_status) {
        i2c_status = (unsigned short)e_status;
        return ERROR;
      }
    }

    return SUCCESS;
  }


  __STATIC_INLINE ErrorStatus i2c_write(const char addr, const char *data, unsigned len) {
    I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE;
    if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;

    I2C1->DR = (unsigned) addr << 1;
    if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;

    (void) I2C1->SR2;

    for(unsigned i = 0; i < len; i++) {
      if (i2c_check(I2C_SR1_TXE) == ERROR) return ERROR;
      I2C1->DR = data[i];
    }

    if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;

    I2C1->CR1 = I2C_CR1_STOP | I2C_CR1_ACK | I2C_CR1_PE;
    return (ErrorStatus)(I2C1->SR1 & I2C_ERROR);
  }


  __STATIC_INLINE ErrorStatus i2c_read(const char addr, volatile char *data, unsigned len) {

    I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE;
    if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;

    I2C1->DR = (char)(addr << 1) + 1;
    if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;
    if (len == 1) I2C1->CR1 = I2C_CR1_PE;                 /* reset ACK bit              */

    (void) I2C1->SR2;

    for(unsigned i = 0; i < len; i++) {
      if (i == len - 1) I2C1->CR1 = I2C_CR1_PE;           /* reset ACK bit              */
      if (i2c_check(I2C_SR1_RXNE) == ERROR) return ERROR;
      data[i] = (char) I2C1->DR;
    }

    if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;
    I2C1->CR1 = I2C_CR1_STOP | I2C_CR1_ACK | I2C_CR1_PE;

    return (ErrorStatus)(I2C1->SR1 & I2C_ERROR);
  }

  __STATIC_INLINE ErrorStatus i2c_read_reg(const char addr, char *data, char reg, unsigned len) {
    I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE; /* generate START             */
    if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;

    I2C1->DR = (unsigned) addr << 1;                      /* send slave address         */
    if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;

    (void) I2C1->SR2;                                     /* dummy read status register */
    if (i2c_check(I2C_SR1_TXE) == ERROR) return ERROR;

    I2C1->DR = reg;                                       /* send register number       */
    if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;

    I2C1->CR1 = I2C_CR1_START | I2C_CR1_ACK | I2C_CR1_PE; /* generate RE-START          */
    if (i2c_check(I2C_SR1_SB) == ERROR) return ERROR;

    I2C1->DR = (char)(addr << 1) + 1;                     /* send slave addr + read req */
    if (i2c_check(I2C_SR1_ADDR) == ERROR) return ERROR;

    if (len == 1) I2C1->CR1 = I2C_CR1_PE;                 /* reset ACK bit              */

    (void) I2C1->SR2;                                     /* dummy read status register */

    for(unsigned i = 0; i < len; i++) {
      if (i == len - 1) I2C1->CR1 = I2C_CR1_PE;           /* reset ACK bit              */
      if (i2c_check(I2C_SR1_RXNE) == ERROR) return ERROR;
      data[i] = (char) I2C1->DR;                          /* store received data        */
    }

    if (i2c_check(I2C_SR1_BTF) == ERROR) return ERROR;
    I2C1->CR1 = I2C_CR1_STOP | I2C_CR1_ACK | I2C_CR1_PE;  /* generate STOP              */

    return (ErrorStatus)(I2C1->SR1 & I2C_ERROR);
  }
#endif

#ifdef __cplusplus
}
#endif

#endif /* __MAIN_H */
MAIN_H

#
# generate main.c
#

cat <<MAIN_C >main.c
#include <stdio.h>
#include "main.h"

#if I2C_EN
  unsigned short i2c_status;
#endif

#if BTN_EN
  enum {
    button_1_pressed  = (1 << 0),
    button_2_pressed  = (1 << 1),
    button_1_released = (1 << 16),
    button_2_released = (1 << 17)
  };
  static volatile unsigned button_state;
#endif

#if RTC_EN
  static volatile unsigned rtc_flag;
#endif

#if TIM2_EN
  static volatile unsigned tim2_counter;
#endif

#if ADC_EN
  static unsigned adc_data;
#endif

#if RNG_EN
  int rnd(void);             /* Get pseudo-random number            */
  void srnd(unsigned seed);  /* Seed pseudo-random number generator */
#endif

int main(void) {

  init();

  #if FLASH_EN
    #if defined LOCK_FIRMWARE && LOCK_FIRMWARE != 0
      if (!READ_REG_BIT(FLASH->OBR, FLASH_OBR_RDPRT)) {        /* Check RDP level status            */
        lock_firmware(NULL, NULL);                             /* Enable read- and write-protect    */
      }
    #endif
  #endif

#if USART_EN || SPI_EN || I2C_EN || BTN_EN || RTC_EN || TIM2_EN || CRC_EN || ADC_EN || RNG_EN
  for(int i = 0; i <= INT32_MAX;) {
    union {
      char pbuf[160];
      unsigned ubuf[sizeof(160/sizeof(unsigned))];
    } z;
    #if RNG_EN
      i = snprintf(z.pbuf, sizeof(z.pbuf), "Test #0x%02X", rnd() % UINT8_MAX);
    #else
      static char loop_counter;
      i = snprintf(z.pbuf, sizeof(z.pbuf), "Test #0x%02X", ++loop_counter);
    #endif
#else
  for(;;) {
    #define VOID_LOOP
#endif

    #if I2C_EN
      char x[0x13];
      i2c_read_reg(0x68, x, 0, sizeof(x));  /* Read DS1307/DS3231 register pool */
      if (i2c_status == 0) {
        i += snprintf((char*)&z.pbuf[i], sizeof(z.pbuf) - (unsigned) i, "; I2C: %02X:%02X:%02X", x[2], x[1], x[0]);
      } else {
        i += snprintf((char*)&z.pbuf[i], sizeof(z.pbuf) - (unsigned) i, "; I2C ERR: %04X", i2c_status);
      }
    #endif

    #if SPI_EN
      CS_LOW();
        spi_xfer(0x00);
        char y = spi_xfer(UINT8_MAX);
      CS_HIGH();
      i += snprintf((char*)&z.pbuf[i], sizeof(z.pbuf) - (unsigned) i, "; SPI: 0x%02X", y);
    #endif

    #if BTN_EN
      i += snprintf((char*)&z.pbuf[i], sizeof(z.pbuf) - (unsigned) i, "; KEY: %s/%s", (button_state & button_1_released) ? "ON" : "OFF",
                                                                                      (button_state & button_2_released) ? "ON" : "OFF");
      button_state &= (unsigned)~(button_1_released | button_2_released);
    #endif

    #if RTC_EN
      time_struct_t tm;
      unixtime_to_time(rtc_read_counter(), &tm);
      i += snprintf((char*)&z.pbuf[i], sizeof(z.pbuf) - (unsigned) i, "; RTC/%s: %02u.%02u.%02u %02u:%02u:%02u",
             ((RCC->BDCR & RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL_LSE) ? "LSE" :
             ((RCC->BDCR & RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL_HSE) ? "HSE" :
             ((RCC->BDCR & RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL_LSI) ? "LSI" : "UNK",
             tm.day, tm.month, tm.year, tm.hour, tm.minute, tm.second);
    #endif

    #if TIM2_EN
      i += snprintf((char*)&z.pbuf[i], sizeof(z.pbuf) - (unsigned) i, "; TIM2: %08X", tim2_counter);
    #endif

    #if CRC_EN
      i += snprintf((char*)&z.pbuf[i], sizeof(z.pbuf) - (unsigned) i, "; CRC: %08X", crc32_zlib(z.ubuf, sizeof(z.ubuf)));
    #endif

    #if ADC_EN
      short t;
      unsigned short v;
      get_adc_internals(&t, &v);
      i += snprintf((char*)&z.pbuf[i], sizeof(z.pbuf) - (unsigned) i, "; ADC: %u.%03u/%d", v / 1000, v % 1000, t);
    #endif

    #if RNG_EN
      i += snprintf((char*)&z.pbuf[i], sizeof(z.pbuf) - (unsigned) i, "; RNG: %04X", rnd());
    #endif

    #if USART_EN
      z.pbuf[i++] = '\n';
      z.pbuf[i] = 0;
      uputs(z.pbuf);
    #endif

    #if IWDG_EN
      IWDG->KR = 0xAAAA;
    #endif

    #if !defined VOID_LOOP
      int j = 1000;
      do {

        #if ADC_EN
          adc_data = (adc_data << 1) | adc_get_random_bit();
        #endif

        #if RTC_EN
          if (READ_MEM_BIT(rtc_flag, RTC_CRL_SECF)) {
            CLEAR_MEM_BIT(rtc_flag, RTC_CRL_SECF);
            j = 0;
          }
        #else
          j -= GET_TICK();
        #endif

        #if WWDG_EN
          if ((WWDG->CR & WWDG_CR_T) < WWDG_WINDOW) {
            /* RESET WWDG */
            WWDG->CR = WWDG_COUNTER;
          }
        #endif

      } while(j);
    #else
      #if WWDG_EN
        if ((WWDG->CR & WWDG_CR_T) < WWDG_WINDOW) {
          /* RESET WWDG */
          WWDG->CR = WWDG_COUNTER;
        }
      #endif
    #endif
  }

  return 0;
}


void SysTick_Handler(void) {
  static unsigned t_cnt;
  if (++t_cnt == 1000) { t_cnt = 0; }         /* Count to 1000 then reset */
  GPIOC->BSRR = GPIO_BSRR_BR13 * ((t_cnt == 970) || (t_cnt == 910) || (t_cnt == 850));
  GPIOC->BSRR = GPIO_BSRR_BS13 * ((t_cnt == 940) || (t_cnt == 880) || (t_cnt == 0));

  #if BTN_EN
    enum {CURRENT = 0, PREVIOUS = 1, TOTAL = 2};
    static unsigned btn[TOTAL][TOTAL];

    btn[0][CURRENT] = (btn[0][CURRENT] << 1) | !READ_REG_BIT(GPIOB->IDR, GPIO_IDR_IDR0);
    btn[1][CURRENT] = (btn[1][CURRENT] << 1) | !READ_REG_BIT(GPIOB->IDR, GPIO_IDR_IDR1);

    if ((btn[0][CURRENT] == UINT32_MAX) && (btn[0][PREVIOUS] != UINT32_MAX)) {
      SET_MEM_BIT(button_state, button_1_pressed);
    }
    if ((btn[1][CURRENT] == UINT32_MAX) && (btn[1][PREVIOUS] != UINT32_MAX)) {
      SET_MEM_BIT(button_state, button_2_pressed);
    }
    if ((btn[0][CURRENT] == 0) && (btn[0][PREVIOUS] != 0)) {
      SET_MEM_BIT(button_state, button_1_released);
    }
    if ((btn[1][CURRENT] == 0) && (btn[1][PREVIOUS] != 0)) {
      SET_MEM_BIT(button_state, button_2_released);
    }
    btn[0][PREVIOUS] = btn[0][CURRENT];
    btn[1][PREVIOUS] = btn[1][CURRENT];
  #endif
}

#if RTC_EN
  void RTC_IRQHandler(void) {                   /* RTC global interrupt handler  */

    if (READ_REG_BIT(RTC->CRL, RTC_CRL_ALRF)) {
      CLEAR_REG_BIT(RTC->CRL, RTC_CRL_ALRF);
      SET_MEM_BIT(rtc_flag, RTC_CRL_ALRF);
    }

    if (READ_REG_BIT(RTC->CRL, RTC_CRL_SECF)) {
      CLEAR_REG_BIT(RTC->CRL, RTC_CRL_SECF);
      SET_MEM_BIT(rtc_flag, RTC_CRL_SECF);
    }

  }

  void RTCAlarm_IRQHandler(void) {              /* RTC alarm interrupt handler   */

    if (EXTI->PR & EXTI_PR_PR17) {
      EXTI->PR = EXTI_PR_PR17;
    }

  }
#endif

#if TIM2_EN
  void TIM2_IRQHandler(void) {
    if (READ_REG_BIT(TIM2->SR, TIM_SR_UIF)) {
      CLEAR_REG_BIT(TIM2->SR, TIM_SR_UIF);
    } else if (READ_REG_BIT(TIM2->SR, TIM_SR_CC1IF)) {
      CLEAR_REG_BIT(TIM2->SR, TIM_SR_CC1IF);
    } else if (READ_REG_BIT(TIM2->SR, TIM_SR_CC2IF)) {
      CLEAR_REG_BIT(TIM2->SR, TIM_SR_CC2IF);
    } else if (READ_REG_BIT(TIM2->SR, TIM_SR_CC3IF)) {
      CLEAR_REG_BIT(TIM2->SR, TIM_SR_CC3IF);
    } else if (READ_REG_BIT(TIM2->SR, TIM_SR_CC4IF)) {
      CLEAR_REG_BIT(TIM2->SR, TIM_SR_CC4IF);
    }
    tim2_counter++;
  }
#endif

#if ADC_EN
  void ADC1_2_IRQHandler(void) {
    ADC1->SR = 0;
  }
#endif

#if EXTI_EN
  void EXTI9_5_IRQHandler(void) {                               /* EXTI line 8 interrupt handler      */
    if (READ_REG_BIT(EXTI->PR, EXTI_PR_PR8)) {
      EXTI->PR = EXTI_PR_PR8;
    }
  }
#endif

#if WWDG_EN
  void WWDG_IRQHandler(void) {
    WWDG->SR = 0;
    WWDG->CR = 0x7F;
  }
#endif

#if !defined NO_HF_IRQ
  void __attribute__((noreturn)) HardFault_Handler(void) {
    for(;;) {
      SW_PIN(C, 13, DOWN);
      DELAY_MS(60);
      SW_PIN(C, 13, UP);
      DELAY_MS(60);
    }
  }
#endif

#if RNG_EN
  static unsigned rnext;

  int rnd(void) {
    rnext = rnext * 1103515245 + 12345;
    return rnext / 65536 % 32768;
  }


  void srnd(unsigned seed) {
    rnext = seed;
  }
#endif

MAIN_C

#
# generate Makefile
#

cat <<MAKEFILE >Makefile
TARGET = project
BUILD_DIR = build

SRC = main.c system_stm32f1xx.c
ASM = startup_stm32f103xb.s
MCU = -mcpu=cortex-m3 -mthumb
DEF = -DSTM32F103xB
INC = -I.
OPT = -O3 -g0 -flto

ifdef GCC_PATH
  TOOLCHAIN = \$(GCC_PATH)/arm-none-eabi-
else
  TOOLCHAIN = arm-none-eabi-
endif

CC = \$(TOOLCHAIN)gcc
AS = \$(TOOLCHAIN)gcc -x assembler-with-cpp
CP = \$(TOOLCHAIN)objcopy
SZ = \$(TOOLCHAIN)size

HEX = \$(CP) -O ihex
BIN = \$(CP) -O binary -S

FLAG = \$(MCU) \$(DEF) \$(INC) -Wall -Werror -Wextra -Wpedantic -fdata-sections -ffunction-sections -std=gnu11

FLAG += -MMD -MP -MF"\$(@:%.o=%.d)"

ifeq (\$(OS), Windows_NT)

    FLAG += -D WIN32
    ifeq (\$(PROCESSOR_ARCHITEW6432), AMD64)
        FLAG += -D AMD64
    else
        ifeq (\$(PROCESSOR_ARCHITECTURE), AMD64)
            FLAG += -D AMD64
        endif
        ifeq (\$(PROCESSOR_ARCHITECTURE), x86)
            FLAG += -D IA32
        endif
    endif

    STLINK = ST-LINK_CLI.exe
    STLINK_FLAGS = -c UR -V -P \$(BUILD_DIR)/\$(TARGET).hex -HardRst -Run

else

    UNAME_S := \$(shell uname -s)
    ifeq (\$(UNAME_S), Linux)
        FLAGS += -D LINUX
    endif
    ifeq (\$(UNAME_S), Darwin)
        FLAGS += -D OSX
    endif
    UNAME_P := \$(shell uname -p)
    ifeq (\$(UNAME_P), x86_64)
        FLAGS += -D AMD64
    endif
    ifneq (\$(filter %86, \$(UNAME_P)),)
        FLAGS += -D IA32
    endif
    ifneq (\$(filter arm%, \$(UNAME_P)),)
        FLAGS += -D ARM
    endif

    STLINK = st-flash
    STLINK_FLAGS = --reset --format ihex write \$(BUILD_DIR)/\$(TARGET).hex

endif

LIB = -lc -lm -lnosys
LDSCRIPT = STM32F103XB_FLASH.ld
LDFLAGS = \$(MCU) -specs=nano.specs -T\$(LDSCRIPT) \$(LIB) -Wl,-Map=\$(BUILD_DIR)/\$(TARGET).map,--cref -Wl,--gc-sections

all: \$(BUILD_DIR)/\$(TARGET).elf \$(BUILD_DIR)/\$(TARGET).hex \$(BUILD_DIR)/\$(TARGET).bin

OBJ = \$(addprefix \$(BUILD_DIR)/,\$(notdir \$(SRC:.c=.o)))
vpath %.c \$(sort \$(dir \$(SRC)))

OBJ += \$(addprefix \$(BUILD_DIR)/,\$(notdir \$(ASM:.s=.o)))
vpath %.s \$(sort \$(dir \$(ASM)))

\$(BUILD_DIR)/%.o: %.c Makefile | \$(BUILD_DIR)
	\$(CC) -c \$(FLAG) \$(OPT) \$(EXT) \$< -o \$@

\$(BUILD_DIR)/%.o: %.s Makefile | \$(BUILD_DIR)
	\$(AS) -c \$(FLAG) \$(OPT) \$(EXT) -Wa,-a,-ad,-alms=\$(BUILD_DIR)/\$(notdir \$(<:.c=.lst)) \$< -o \$@

\$(BUILD_DIR)/\$(TARGET).elf: \$(OBJ) Makefile
	\$(CC) \$(OBJ) \$(LDFLAGS) \$(OPT) \$(EXT) -o \$@
	\$(SZ) \$@

\$(BUILD_DIR)/%.hex: \$(BUILD_DIR)/%.elf | \$(BUILD_DIR)
	\$(HEX) \$< \$@

\$(BUILD_DIR)/%.bin: \$(BUILD_DIR)/%.elf | \$(BUILD_DIR)
	\$(BIN) \$< \$@

\$(BUILD_DIR):
	mkdir \$@

debug: OPT = -Og -g -gdwarf
debug: FLAG += -DUSE_SWD=1
debug: all

# Display compiler version information.
gccversion :
	@\$(CC) --version

# Program the device.
program: \$(BUILD_DIR)/\$(TARGET).hex
	\$(STLINK) \$(STLINK_FLAGS)

clean:
	rm -fR \$(BUILD_DIR)

-include \$(wildcard \$(BUILD_DIR)/*.d)

# *** EOF ***
MAKEFILE

cat <<DEBUG_JLINK >project.jdebug
void OnProjectLoad (void) {
  Project.SetDevice ("STM32F103C8");
  Project.SetHostIF ("USB", "");
  Project.SetTargetIF ("SWD");
  Project.SetTIFSpeed ("4 MHz");
  Project.AddSvdFile ("\$(InstallDir)/Config/CPU/Cortex-M3.svd");
  Project.AddSvdFile ("STM32F103xx.svd");
  File.Open ("build/project.elf");
}

void AfterTargetReset (void) {
  _SetupTarget();
}

void AfterTargetDownload (void) {
  _SetupTarget();
}

void _SetupTarget(void) {
  unsigned int SP;
  unsigned int PC;
  unsigned int VectorTableAddr;

  VectorTableAddr = Elf.GetBaseAddr();

  SP = Target.ReadU32(VectorTableAddr);
  if (SP != 0xFFFFFFFF) {
    Target.SetReg("SP", SP);
  }

  PC = Elf.GetEntryPointPC();
  if (PC != 0xFFFFFFFF) {
    Target.SetReg("PC", PC);
  } else {
    Util.Error("Project script error: failed to set up entry point PC", 1);
  }
}
DEBUG_JLINK

#
# run 'make' utility
#

make

echo
echo "type \"make program\" to download the firmware into the chip."
